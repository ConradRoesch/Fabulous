var suggestions=document.getElementById('suggestions'),search=document.getElementById('search');search!==null&&document.addEventListener('keydown',inputFocus);function inputFocus(a){a.ctrlKey&&a.key==='/'&&(a.preventDefault(),search.focus()),a.key==='Escape'&&(search.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(c){const d=suggestions.classList.contains('d-none');if(d)return;const a=[...suggestions.querySelectorAll('a')];if(a.length===0)return;const b=a.indexOf(document.activeElement);if(c.key==="ArrowUp"){c.preventDefault();const d=b>0?b-1:0;a[d].focus()}else if(c.key==="ArrowDown"){c.preventDefault();const d=b+1<a.length?b+1:b;a[d].focus()}}(function(){var a=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});a.add({id:0,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/",title:"Controls",description:"Controls",content:""}).add({id:1,href:"https://fsprojects.github.io/Fabulous/docs/v2/getting-started/",title:"Getting started",description:"TBD",content:"TBD\n"}).add({id:2,href:"https://fsprojects.github.io/Fabulous/docs/v1/getting-started/",title:"Getting started",description:"Install Visual Studio or Visual Studio for Mac and enable both Xamarin and .NET Core support, these are listed as \u0026lsquo;Mobile development with .NET\u0026rsquo; and \u0026lsquo;.NET Core Cross-platform development\u0026rsquo; respectively.\n  Open a command prompt window and install the template pack by entering:\n  dotnet new -i Fabulous.XamarinForms.Templates   Navigate to a folder in the command prompt window where your new app can be created and enter:  dotnet new fabulous-xf-app -n SqueakyApp   Open, edit and build in Visual Studio or Visual Studio for Mac  SqueakyApp/SqueakyApp.",content:"  Install Visual Studio or Visual Studio for Mac and enable both Xamarin and .NET Core support, these are listed as \u0026lsquo;Mobile development with .NET\u0026rsquo; and \u0026lsquo;.NET Core Cross-platform development\u0026rsquo; respectively.\n  Open a command prompt window and install the template pack by entering:\n  dotnet new -i Fabulous.XamarinForms.Templates   Navigate to a folder in the command prompt window where your new app can be created and enter:  dotnet new fabulous-xf-app -n SqueakyApp   Open, edit and build in Visual Studio or Visual Studio for Mac  SqueakyApp/SqueakyApp.sln    Before deploying and running, first connect and enable your device, choose between iOS (Emulator, Device) or Android (Emulator, Device).\n  To run, set either your Android or iOS project as the startup project, then use F5.\n  By default iOS and Android projects are created. But you can also target WPF with --WPF, UWP with --UWP, macOS with --macOS and/or GTK with --GTK. Here some common examples, but feel free to change the targets to the ones you require:\nAndroid only:\ndotnet new fabulous-xf-app -n SqueakyApp --iOS=false  iOS only:\ndotnet new fabulous-xf-app -n SqueakyApp --Android=false  WPF only:\ndotnet new fabulous-xf-app -n SqueakyApp --WPF --Android=false --iOS=false  UWP only:\ndotnet new fabulous-xf-app -n SqueakyApp --UWP --Android=false --iOS=false  macOS only:\ndotnet new fabulous-xf-app -n SqueakyApp --macOS --Android=false --iOS=false  GTK only:\ndotnet new fabulous-xf-app -n SqueakyApp --GTK --Android=false --iOS=false  All 6 platforms:\ndotnet new fabulous-xf-app -n SqueakyApp --WPF --UWP --macOS --GTK   If you are using Visual Studio for Mac and you want to start with File -\u0026gt; New, make sure you target \u0026ldquo;.NET Standard\u0026rdquo; to add the references to Fabulous:   File -\u0026gt; New Solution Multiplatform App -\u0026gt; Blank Forms App (F#) Shared Code -\u0026gt; Use .NET Standard\n Structure of a Project # The majority of your app logic will be in your shared code project, normally a .NET Standard 2.0 project.\nYour project will also have iOS and Droid projects for actually running the core logic on these different platforms.\nRunning # To run, set your target to Any CPU (Android) or iPhone or iPhone Simulator, then choose your device and launch.\nYou may need to install Android, iOS and/or other SDK tooling.\nIf running on-device you may need to enable developer settings for your device, or, in the case of iOS, enable free provisioning.\nA Basic Example # Here is a full example of an app:\n// replace with the namespace of your app namespace ExampleApp open Fabulous open Fabulous.XamarinForms open Xamarin.Forms module App = /// The messages dispatched by the view type Msg = | Pressed /// The model from which the view is generated type Model = { Pressed: bool } /// Returns the initial state let init() = { Pressed = false } /// The function to update the view let update (msg: Msg) (model: Model) = match msg with | Pressed -\u0026gt; { model with Pressed = true } /// The view function giving updated content for the page let view (model: Model) dispatch = View.ContentPage( View.StackLayout([ if model.Pressed then View.Label(\u0026quot;I was pressed!\u0026quot;) else View.Button( text = \u0026quot;Press Me!\u0026quot;, command = fun () -\u0026gt; dispatch Pressed ) ]) ) type App () as app = inherit Application () let runner = Program.mkSimple App.init App.update App.view // use Program.mkProgram if your app contains commands (see 'update') |\u0026gt; Program.withConsoleTrace |\u0026gt; XamarinFormsProgram.run app  The init function returns your initial state, and each model gets an update function for message processing. The view function computes an immutable Xaml-like description. In the above example, the choice between a label and button depends on the model.Pressed value.\nSome advantages of using an immutable model are:\n It is easy to unit test your init, update and view functions You can save/restore your model relatively easily It makes tracing causality usually very simple  Samples # The sample CounterApp contains a slightly larger example of Button/Label/Slider elements.\nThe sample TicTacToe contains examples of the Grid and Image elements.\nThe sample AllControls contains examples of instantiating most elements in Xamarin.Forms.Core.\nThe sample Calculator (original external sample) is a small calculator app.\nThe external sample PocketPiggyBank is a small client-server app with login authentication. (Note: because this is an external sample it may not be up-to-date with the latest version of this library.)\nThe external sample FabulousContacts is a multi-page contacts app featuring maps, group-lists and cross-page messages. (Note: because this is an external sample it may not be up-to-date with the latest version of this library.)\nThe external sample FabulousPlanets is a multi-page app featuring facts on the planets in the Solar System. It uses Urho3D and Fabulous (Note: because this is an external sample it may not be up-to-date with the latest version of this library.)\nThe external sample Fabulous + GraphQL Type Provider is a small app that demonstrates how to use the type provider for GraphQL FSharp.Data.GraphQL.\nSee also the curated list Awesome Fabulous.\nFurther Resources # Presentation: Making Mobile App Development Simple with F#\nPresentation: Building mobile apps with F# using Xamarin - Jim Bennett - Xamarin University Guest Lecture\n General Docs #  Xamarin Xamarin Forms  Performance and Security Deployment and Debugging Cross-platform for Desktop Developers   Xamarin Essentials  Android Setup #  SDK Emulator Device  iOS Setup #  SDK Emulator Pair to Mac Device  Contributing # Please contribute to this library through issue reports, pull requests, code reviews and discussion.\n Submit a fix to this guide  "}).add({id:3,href:"https://fsprojects.github.io/Fabulous/docs/about/",title:"About",description:"About",content:""}).add({id:4,href:"https://fsprojects.github.io/Fabulous/docs/v2/api/controls/",title:"Controls",description:"Controls API Reference",content:""}).add({id:5,href:"https://fsprojects.github.io/Fabulous/docs/v1/tutorials/",title:"Tutorials",description:"Tutorials",content:""}).add({id:6,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/",title:"API Reference",description:"API Reference",content:""}).add({id:7,href:"https://fsprojects.github.io/Fabulous/docs/v2/tutorials/",title:"Tutorials",description:"Tutorials",content:""}).add({id:8,href:"https://fsprojects.github.io/Fabulous/docs/v1/extensions/",title:"Extensions",description:"Extensions",content:""}).add({id:9,href:"https://fsprojects.github.io/Fabulous/docs/v2/api/",title:"API Reference",description:"API Reference",content:""}).add({id:10,href:"https://fsprojects.github.io/Fabulous/docs/v2/architecture/",title:"Architecture",description:"Architecture",content:""}).add({id:11,href:"https://fsprojects.github.io/Fabulous/docs/about/fabulous-for-xamarinforms/",title:"Fabulous for Xamarin.Forms",description:"Write cross-platform apps with Xamarin.Forms, using MVU architecture and dynamic UI",content:"Never write a ViewModel class again! Conquer the world with clean dynamic UIs!\nThis library allows you to combine the power of functional programming and the simple Model-View-Update architecture to build any kind of mobile and desktop applications with an expressive, dynamic and clean UI DSL. Go cross-platform and target iOS, Android, Mac, WPF and more!\nFabulous for Xamarin.Forms is build on Fabulous, which aims to provide all the tools to let you create your own mobile and desktop apps using only F# and the Model-View-Update architecture (shorten to MVU), with a great F# DSL for building dynamic UIs. The combination of F# and MVU makes for a great development experience.\n The amount of code I\u0026rsquo;m not writing is great! @jimbobbennett\n This guide augments the primary Xamarin.Forms documentation with information specific to the Fabulous programming model. For detailed guides to different parts of the library, please visit the respective pages via the links below:\n NOTE: A comprehensive guide to Xamarin.Forms programming is available for free in the Creating Mobile Apps with Xamarin.Forms ebook. The book deals with C# MVVM programming but many details are relevant here.\n "}).add({id:12,href:"https://fsprojects.github.io/Fabulous/docs/about/fabulous-staticview/",title:"Fabulous.StaticView (deprecated)",description:"Write cross-platform apps with Xamarin.Forms, using MVU architecture and static XAML UI\nIn some circumstances there are advantages to using static Xaml, and static bindings from the model to those views. This is called \u0026ldquo;Half Elmish\u0026rdquo; and is the primary technique used by Elmish.WPF at time of writing. (It was also the original technique used by this repo and the prototype Elmish.Forms).\n\u0026ldquo;Half Elmish\u0026rdquo; is a pragmatic choice to allow, but doesn\u0026rsquo;t provide the same level of cognitive-simplicity.",content:"Write cross-platform apps with Xamarin.Forms, using MVU architecture and static XAML UI\nIn some circumstances there are advantages to using static Xaml, and static bindings from the model to those views. This is called \u0026ldquo;Half Elmish\u0026rdquo; and is the primary technique used by Elmish.WPF at time of writing. (It was also the original technique used by this repo and the prototype Elmish.Forms).\n\u0026ldquo;Half Elmish\u0026rdquo; is a pragmatic choice to allow, but doesn\u0026rsquo;t provide the same level of cognitive-simplicity. In the words of Jim Bennett:\n As a C#/XAML dev I really like the half Elmish model. I’m comfortable with XAML so like being able to use the Elmish bits to create a nice immutable model and have clean code, but still using XAML and binding as I’m comfortable there. This feels more like how existing C# Xamarin devs would move to F#. Full elmish is how F# devs will move to Xamarin.\n Static Xaml + bindings has signifcant pros:\n Pro: in some circumstances perf can be better Pro: you can interact with existing xaml assets Pro: you can interact with 3rd party controls relatively easily Con: you have to know a lot more about Xaml (e.g. binding, commands, templating, converters) Con: you get more files in your project (e.g. 3 instead of 1, even for simple examples) Con: you are more reliant on tooling (which is often a bit flakey\u0026hellip;) Con: you may end up using more mutable data structures Con: there are more failure points (e.g. magic strings to link the Xaml to the code through binding etc.). Con: the Xaml is static, and only made dynamic through the addition of control bindings to turn elements on/off  If you want to use static Xaml, then you will need to do bindings to that View. Bindings in your XAML code will look like typical bindings, but a bit of extra code is needed to map those bindings to your Elmish model. These are the viewBindings, which expose parts of the model to the view.\nHere is a full example (excluding Xaml):\nnamespace CounterApp open Fabulous.Core open Fabulous.StaticViews open Xamarin.Forms type Model = { Count : int Step : int } type Msg = | Increment | Decrement | Reset | SetStep of int type CounterApp () = inherit Application () let init () = { Count = 0; Step = 3 } let update msg model = match msg with | Increment -\u0026gt; { model with Count = model.Count + model.Step } | Decrement -\u0026gt; { model with Count = model.Count - model.Step } | Reset -\u0026gt; init () | SetStep n -\u0026gt; { model with Step = n } let view () = CounterPage (), [ \u0026quot;CounterValue\u0026quot; |\u0026gt; Binding.oneWay (fun m -\u0026gt; m.Count) \u0026quot;CounterValue2\u0026quot; |\u0026gt; Binding.oneWay (fun m -\u0026gt; m.Count + 1) \u0026quot;IncrementCommand\u0026quot; |\u0026gt; Binding.msg Increment \u0026quot;DecrementCommand\u0026quot; |\u0026gt; Binding.msg Decrement \u0026quot;ResetCommand\u0026quot; |\u0026gt; Binding.msgIf Reset (fun m -\u0026gt; m \u0026lt;\u0026gt; init ()) \u0026quot;ResetVisible\u0026quot; |\u0026gt; Binding.oneWay (fun m -\u0026gt; m \u0026lt;\u0026gt; init ()) \u0026quot;StepValue\u0026quot; |\u0026gt; Binding.twoWay (fun m -\u0026gt; double m.Step) (fun v -\u0026gt; SetStep (int (v + 0.5))) ] let runner = Program.mkSimple init update view |\u0026gt; Program.withConsoleTrace |\u0026gt; Program.runWithStaticView do base.MainPage \u0026lt;- runner.InitialMainPage  There are helper functions to create bindings located in the Binding module:\n Binding.oneWay getter  Basic source-to-view binding. Maps to BindingMode.OneWay. Takes a getter ('model -\u0026gt; 'a)   Binding.twoWay getter setter  Binding from source to view, or view to source, and usually used for input controls. Takes a getter ('model -\u0026gt; 'a) and a setter ('a -\u0026gt; 'model -\u0026gt; 'msg) that returns a message.   Binding.oneWayFromView setter  Binding from view to source, and usually used for input controls. Takes a a setter ('a -\u0026gt; 'model -\u0026gt; 'msg) that returns a message.   Binding.twoWayValidation getter setter  Binding from source to view and view to source, and usually used for input controls. Maps to BindingMode.TwoWay. Setter will implement validation. Takes a getter ('model -\u0026gt; 'a) and a setter ('a -\u0026gt; 'model -\u0026gt; Result\u0026lt;'msg,string\u0026gt;) that indicates whether the input is valid or not.   Binding.msg  Basic command binding to dispatch a message Takes an execute function ('model -\u0026gt; 'msg)   Binding.msgIf  Conditional command binding to dispatch a message Takes an execute function ('model -\u0026gt; 'msg) and a canExecute function ('model -\u0026gt; bool)   Binding.msgWithParamIf  Conditional command binding to dispatch a message, with an additional CommandParameter Takes an execute function ('model -\u0026gt; 'msg) and a canExecute function ('model -\u0026gt; bool)   Binding.subView initf getter toMsg viewBindings name  Composite model binding Takes a sub-model initializer sub-model getter ('model -\u0026gt; '_model) to fetch part of a model, a message embedder ('_msg -\u0026gt; 'msg) to embed sub-component messages into a larger space of messages, and the composite sub-model viewBindings, and a name for the sub-model   oneWayMap  One-way binding that applies a map when passing data to the view. Takes a getter ('model -\u0026gt; 'a) and a mapper ('a -\u0026gt; 'b).    The string piped to each binding is the name of the property as referenced in the XAML binding.\n"}).add({id:13,href:"https://fsprojects.github.io/Fabulous/docs/about/they-use-fabulous/",title:"They use Fabulous",description:"Tawasal # Website | Google Play Store | App Store\nDescription # Tawasal is a secure multi-purpose messenger and superapp, offering free voice, text, videoconferencing and lifestyle services to clients around the world. Tawasal introduces a full suite of exciting features with something for everyone, from live sports, text, broadcasts and giveaways, to payments and news services.\nWhy they chose Fabulous? # Our team at Tawasal was looking for cross platform solution that was stable \u0026amp; supported.",content:"Tawasal # Website | Google Play Store | App Store\nDescription # Tawasal is a secure multi-purpose messenger and superapp, offering free voice, text, videoconferencing and lifestyle services to clients around the world. Tawasal introduces a full suite of exciting features with something for everyone, from live sports, text, broadcasts and giveaways, to payments and news services.\nWhy they chose Fabulous? # Our team at Tawasal was looking for cross platform solution that was stable \u0026amp; supported. When we started looking into what Xamarin has to offer, we came across Fabulous - and due to usage of modern \u0026amp; reactive MVU pattern, as well as the ability to build basically anything using native Xamarin.iOS / Xamarin.Android bindings (using less code \u0026amp; functional approach with F#), while still maintaining a large shared codebase our choice was surely Fabulous.\n \n"}).add({id:14,href:"https://fsprojects.github.io/Fabulous/docs/v2/tutorials/using-nightly-builds/",title:"Using nightly builds",description:"On every commit to the v2.0 branch, packages for each project and template are automatically generated and published to the GitHub Packages Registry.\nIf you plan to use those packages, you\u0026rsquo;ll need to add a nuget.config file to your solution folder and you\u0026rsquo;ll need to add a source pointing to https://nuget.pkg.github.com/fsprojects/index.json.\nYou\u0026rsquo;ll also new to generate a GitHub PAT (personal access token) for your account and set that token in the nuget.",content:"On every commit to the v2.0 branch, packages for each project and template are automatically generated and published to the GitHub Packages Registry.\nIf you plan to use those packages, you\u0026rsquo;ll need to add a nuget.config file to your solution folder and you\u0026rsquo;ll need to add a source pointing to https://nuget.pkg.github.com/fsprojects/index.json.\nYou\u0026rsquo;ll also new to generate a GitHub PAT (personal access token) for your account and set that token in the nuget.config file.\nFor instructions on how to generate a GitHub PAT, see Authenticating with a Personal Access Token.\nExample of nuget.config:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;packageSources\u0026gt; \u0026lt;clear /\u0026gt; \u0026lt;add key=\u0026quot;nuget\u0026quot; value=\u0026quot;https://api.nuget.org/v3/index.json\u0026quot; /\u0026gt; \u0026lt;!-- For nightly builds --\u0026gt; \u0026lt;add key=\u0026quot;fsprojects\u0026quot; value=\u0026quot;https://nuget.pkg.github.com/fsprojects/index.json\u0026quot; /\u0026gt; \u0026lt;/packageSources\u0026gt; \u0026lt;packageSourceCredentials\u0026gt; \u0026lt;fsprojects\u0026gt; \u0026lt;add key=\u0026quot;Username\u0026quot; value=\u0026quot;USERNAME\u0026quot; /\u0026gt; \u0026lt;add key=\u0026quot;ClearTextPassword\u0026quot; value=\u0026quot;TOKEN\u0026quot; /\u0026gt; \u0026lt;/fsprojects\u0026gt; \u0026lt;/packageSourceCredentials\u0026gt; \u0026lt;/configuration\u0026gt;  Using nightly templates # It\u0026rsquo;s the same than above, except you\u0026rsquo;ll need to create nuget.config first so the dotnet CLI can retrieve the templates from GitHub.\nOnce you configured nuget.config, you can run\ndotnet new -i Fabulous.XamarinForms.Templates::XYZ  where XYZ is the latest version from Fabulous.XamarinForms.Templates versions.\n"}).add({id:15,href:"https://fsprojects.github.io/Fabulous/docs/v2/api/extending-controls/",title:"Creating and extending controls",description:"Here, we will explain how to use custom controls with Fabulous.\nIf you are wondering about how to create custom controls, please take a look at the Xamarin.Forms documentation: Customizing an Entry\nOnce you implemented a custom control with Xamarin.Forms, you\u0026rsquo;ll need a wrapper to be able to use it in Fabulous.\nFortunately, creating a wrapper is pretty straightforward.\n// Step 1 - declare a marker for your custom control // Make it inherit the right marker to automatically inherit all existing modifiers (such as Height/Width, Text, etc.",content:"Here, we will explain how to use custom controls with Fabulous.\nIf you are wondering about how to create custom controls, please take a look at the Xamarin.Forms documentation: Customizing an Entry\nOnce you implemented a custom control with Xamarin.Forms, you\u0026rsquo;ll need a wrapper to be able to use it in Fabulous.\nFortunately, creating a wrapper is pretty straightforward.\n// Step 1 - declare a marker for your custom control // Make it inherit the right marker to automatically inherit all existing modifiers (such as Height/Width, Text, etc.) type IMyEntry = inherit Fabulous.XamarinForms.IEntry // Step 2 - create a module to store attributes and constructors module MyEntry = // Step 2.a - register your custom control so Fabulous can instantiate it let WidgetKey = Widgets.register\u0026lt;MyProject.MyEntry\u0026gt;() // Step 2.b - define the attributes you added to the custom control let MandatoryProperty = Attributes.defineBindable\u0026lt;int\u0026gt; MyProject.MyEntry.MandatoryBindableProperty let OptionalProperty = Attributes.defineBindable\u0026lt;string\u0026gt; MyProject.MyEntry.OptionalBindableProperty // Step 2.c - declare the constructors that will be available for use in the view function type Fabulous.XamarinForms.View with static member inline MyEntry\u0026lt;'msg\u0026gt;(text: string, onTextChanged: string -\u0026gt; 'msg, mandatoryValue: int) = WidgetBuilder\u0026lt;'msg, IMyEntry\u0026gt;( WidgetKey, Entry.Text.WithValue(text), // here we reuse existing attributes from the control we inherit Entry.TextChanged.WithValue(fun args -\u0026gt; onTextChanged args.NewTextValue |\u0026gt; box), MandatoryProperty.WithValue(mandatoryValue) // here we add our new attribute ) // Step 3 (optional) - if you have properties in your custom control that are optional, you can declare modifiers to set them [\u0026lt;Extension\u0026gt;] type MyEntryModifiers = /// The # sign before the marker interface is important // It will make this modifier available to other marker interfaces inheriting IMyEntry [\u0026lt;Extension\u0026gt;] static member inline optional(this: WidgetBuilder\u0026lt;'msg, #IMyEntry\u0026gt;, value: string) = this.AddScalar(MyEntry.OptionalProperty.WithValue(value))  Usage:\nopen MyEntry type Msg = | TextChanged of string let view model = MyEntry(model.Text, TextChanged, model.Mandatory) .optional(model.Optional)  Important considerations # Depending on the internal implementation of a control (e.g. in Xamarin.Forms), sometimes a property needs to be updated before another one.\nAn example of this: the Stepper control has a Minimum and Maximum property.\nAccording to the Xamarin.Forms implementation, those properties follow some rules:\n Minimum is required to be less than or equal to Maximum Maximum is required to be more than or equal to Minimum If any of those 2 conditions are not true, InvalidOperationException is thrown  This means if the new minimum value is more than the old maximum value, we need to update maximum first. Same in the other direction.\nTo ensure consistency, Fabulous doesn\u0026rsquo;t take into account the order of declaration. Hence the 2 following codes will have the same behavior:\nStepper() .minimum(1) .maximum(5) Stepper() .maximum(5) .minimum(1)  This could throw an exception if we try to set the minimum to a value superior to the current maximum.\nTo be able to guarantee the order of property updates, we need to store those 2 properties in a single Attribute.\n// Step 1 - create a struct holding both values type [\u0026lt;Struct\u0026gt;] MinMaxValue = { Minimum: float Maximum: float } module Stepper = // Step 2 - define an attribute that will apply the correct update logic let MinimumMaximum = Attributes.define\u0026lt;MinMaxValue\u0026gt; \u0026quot;Stepper_MinimumMaximum\u0026quot; (fun _ newValueOpt node -\u0026gt; let stepper = node.Target :?\u0026gt; Stepper match newValueOpt with | ValueNone -\u0026gt; stepper.ClearValue(Stepper.MinimumProperty) stepper.ClearValue(Stepper.MaximumProperty) | ValueSome { Minimum = min; Maximum = max } -\u0026gt; let currMax = stepper.GetValue(Stepper.MaximumProperty) :?\u0026gt; float if min \u0026gt; currMax then stepper.SetValue(Stepper.MaximumProperty, max) stepper.SetValue(Stepper.MinimumProperty, min) else stepper.SetValue(Stepper.MinimumProperty, min) stepper.SetValue(Stepper.MaximumProperty, max) ) // Step 3 - add a constructor or a modifier that will take the 2 values at the same time type Fabulous.XamarinForms.View with static member inline Stepper\u0026lt;'msg\u0026gt;(min: float, max: float) = WidgetBuilder\u0026lt;'msg, IStepper\u0026gt;( WidgetKey, MinimumMaximum.WithValue({ Minimum = min; Maximum = max }) ) // Step 4 - use it let view model = Stepper(model.Min, model.Max)  "}).add({id:16,href:"https://fsprojects.github.io/Fabulous/docs/v2/architecture/goals-of-v2/",title:"Reasonable goals of v2",description:"Due to the complex nature of GUI framework development, Fabulous v2 represents a substantial amount of work.\nIn order to manage and optimize the time of everyone involved, more reasonable goals are required to get a version 2 out as fast as possible.\nDoing a complete redesign of the architecture + adding .NET 6 / MAUI support at the same time feels really discouraging.\nThat\u0026rsquo;s why this version 2 will be done in 4 separate releases:",content:"Due to the complex nature of GUI framework development, Fabulous v2 represents a substantial amount of work.\nIn order to manage and optimize the time of everyone involved, more reasonable goals are required to get a version 2 out as fast as possible.\nDoing a complete redesign of the architecture + adding .NET 6 / MAUI support at the same time feels really discouraging.\nThat\u0026rsquo;s why this version 2 will be done in 4 separate releases:\n Focus on performance and Xamarin.Forms 5.0 support Migration path from version 1 Components .NET 6 / MAUI support  Focus on performance and extensibility # While Fabulous v1 works perfectly well, it relies a lot on object allocations, does a lot of cache misses, etc.\nThe primary goal of v1 was not to get something optimized but to get something working.\nOver the years, it has become apparent we need to optimize for speed and memory usage.\nEspecially on Android where low-end devices can be found, frequent garbage collections are noticed and can freeze the app, sometimes for up to several seconds!\nAlso in addition to perf improvements, v2 will focus on making extensibility easier.\nTo improve that, here\u0026rsquo;s what will be done:\n Redesign of the internal architecture  Reduce garbage collection to a minimum on hot paths (heavy use of structs, optimize against cache misses, etc) Improve computation speed (micro-benchmarking on critical paths - benchmarking end-to-end on typical use cases)   Implement a generic Reconciler in Core  This will help us optimize allocations and speed It will also be useful for framework integration (like Fabulous.XF, Fabulous.MAUI, etc). They won\u0026rsquo;t need to worry about reconciliation.   Attribute level diff instead of control level diff  This change will make it easier to extend an existing control without having to rewrite the whole mapping each time. (eg. https://github.com/TimLariviere/FabulousContacts/blob/master/FabulousContacts/Controls/BorderedEntry.fs) Such extensibilty can be done via method extensions à la SwiftUI   Decorrelate Update from View  This will be useful in cases where we receive numerous updates in a short timeframe or we received them continously (streams). The runner will still treat all the updates and update the model, but the view will be able to take only the latest available model if diffing is not keeping up with the updates. The update loop will be able to run on another thread since it won\u0026rsquo;t need to access the UI, resulting in faster updates.   Enable having multiple instances of Fabulous in the same app (no singleton)  Today, Fabulous is limited to only 1 Program running at the same time. This change will allow to have multiple programs in a same app - like for example 2 Fabulous controls in a C# XF app.   Add lifecycle to ViewElement (on mount, on dismount, on create, on destroy) Produce smallest binaries as possible  Make sure all unused types are trimmed away by the Android / iOS linkers    This version 2 will focus 100% on dynamic views (main selling point). Fabulous.StaticViews will be removed completely.\nSupport for Fabulous.AdaptiveViews won\u0026rsquo;t be considered.\nRelease target: Early April 2022 (include v2 architecture and XF 5.0 support)\nXamarin.Forms 5.0 support # So that we can validate and use the new architecture of Fabulous v2, a framework integration with XF 5.0 will be required.\nInitially, we wanted to test it with MAUI and only later on write a migration path from Fabulous v1 / XF 5.0 but the development experience with MAUI is still way too fragile as of November 2021.\nFor that reason, we believe it is better to start with Xamarin.Forms 5.0 support.\nHere\u0026rsquo;s what will be done:\n Design a new View DSL  Strongly-typed  Each control will return a typed element instead of just ViewElement This will prevent combining incompatible controls (eg. a Label inside a ListView) This will also prevent combining 2 UIs using incompatible messages   Better for autocompletion  Having uniquely-typed elements, IDEs will be able to show only available properties and events   Better defaults  Each control can have specialized constructors to enforce meaningful defaults (eg. Label will always have Text, Button will always have Text and an Action, etc.)   Easier to extend  Adding a new property to an element will be as simple as creating an extension method (https://github.com/TimLariviere/Fabulous-new/blob/618c8226533134cb73f7f79049d1fa737d2b83d6/src/Fabulous.Maui/Microsoft.Maui.Controls.fs#L363-L394)   No dispatch  Avoid accidentally keeping the dispatch function passed as argument when this one can be swapped with another dispatch at any moment by Fabulous     Update Fabulous.XamarinForms.Generator to generate the wrappers for the new DSL Port all the existing samples to v2 and the new DSL  This is an early example of the new DSL done with MAUI.\ntype Msg = | Increment | Decrement let view model = Application([ Window(\u0026quot;Main\u0026quot;, VerticalStackLayout([ Label($\u0026quot;Hello World from Fabulous: {model.Count}\u0026quot;) .font(Font.SystemFontOfSize(20.)) .horizontalLayoutAlignment(Primitives.LayoutAlignment.Fill) .verticalLayoutAlignment(Primitives.LayoutAlignment.Fill) .horizontalTextAlignment(TextAlignment.Center) .background(SolidPaint(Colors.Red)) Button(\u0026quot;Click me\u0026quot;, Increment) ]) .spacing(10.) .background(SolidPaint(Colors.Aqua)) ) ])  Release target: Early April 2022 (include v2 architecture and XF 5.0 support)\nMigration path from version 1 # When v2 and the new DSL will be validated by early adopters, we will need to work on a migration path for users that developped their apps with Fabulous v1.\nTo permit this, here\u0026rsquo;s what we will be done:\n Check if a new ViewElement can be added to v1 that would host a v2 runner to enable progressive migration Write documentation:  What are the differences between v1 and v2 What are the available features How to migrate from v1 to v2 Add most common migration examples (StackLayout(orientation = vertical, children = [ (...) ]) to VStack() { (...) }, etc.)    Release target: May 2022\nComponents # The concept of components was one of the inital motivators for making a version 2. The idea was to create smaller programs with their own MVU loop and runner, and then embed them in a ViewElement so they can be included in a larger program. This had the advantage to reduce the UI tree to process during diffing.\nTurns out it\u0026rsquo;s not that simple to implement.\n@twop recommended to take a similar approach than Elm: Actor Model. Instead of implementing the concept directly in the core of Fabulous with dedicated widgets, we can create an Actor Model library to facilitate communication between independent parts of the application.\nEach part is given a Process ID and they can send messages to each other using that id. This will still trigger a whole update from the root of the app, but with v2 architecture, diffing should be way more efficient than today so it shouldn\u0026rsquo;t be an issue to not have isolated components.\nInspiration: https://www.youtube.com/watch?v=YV_qrjN8bRA\nWe\u0026rsquo;re still discussing how to implement such a library.\nRelease target: July 2022\n.NET 6 / MAUI support # Finally when everything else will be done and .NET 6.0 / MAUI is in a stable state, we will be able to start working on support for MAUI in Fabulous.\nRelease target: Depends on the MAUI team. Earliest possible - May / June 2022\nWhat about all the other stuff? # Things like LiveUpdate, more advanced use case support, etc won\u0026rsquo;t be included as part of the official repository. At least not initially.\nAnyway, they will have to wait after we get version 2 fully released and production-ready before consideration.\n"}).add({id:17,href:"https://fsprojects.github.io/Fabulous/docs/v2/architecture/virtualized-collections/",title:"Virtualized collections",description:"Virtualized collection enables displaying a scrolling list of data while only instantiating the visible rows. When scrolling, the no longer visible rows are reused and updated with the new data.\nIn Xamarin.Forms, this is done via 2 controls: ListView and CollectionView. Also those controls support grouping data and displaying a group header/footer.\nMy main idea was to let the user pass in its data source and declare a template function (as well as 2 others for header/footer).",content:"Virtualized collection enables displaying a scrolling list of data while only instantiating the visible rows. When scrolling, the no longer visible rows are reused and updated with the new data.\nIn Xamarin.Forms, this is done via 2 controls: ListView and CollectionView. Also those controls support grouping data and displaying a group header/footer.\nMy main idea was to let the user pass in its data source and declare a template function (as well as 2 others for header/footer). Fabulous would just remap the data source (Seq.map templateFn items) and pass it to Xamarin.Forms, avoiding enumeration.\nUsages # let items = [ 1 .. 1000 ] ListView(items) (fun item -\u0026gt; TextCell($\u0026quot;{item}\u0026quot;)) CollectionView(items) (fun item -\u0026gt; Label($\u0026quot;{item}\u0026quot;))  // According to Xamarin.Forms documentation, when grouping, data source should be an IEnumerable of IEnumerable type Group(headerData: string, footerData: string, items: IEnumerable\u0026lt;int\u0026gt;) = inherit ObservableCollection\u0026lt;int\u0026gt;(items) member _.HeaderData = headerData member _.FooterData = footerData let groups = ObservableCollection\u0026lt;Group\u0026gt;( [ for i = 0 .. 100 do Group($\u0026quot;Header {i}\u0026quot;, $\u0026quot;Footer {i}\u0026quot;, [1 .. 100]) ] ) // ListView has no Footer for groups GroupedListView(groups) (fun group -\u0026gt; TextCell(group.HeaderData)) (fun item -\u0026gt; TextCell($\u0026quot;{item}\u0026quot;)) GroupedCollectionView(items) (fun group -\u0026gt; Label(group.HeaderData)) (fun item -\u0026gt; Label($\u0026quot;{item}\u0026quot;) (fun group -\u0026gt; Label(group.FooterData))  How ListView and CollectionView work in Xamarin.Forms # Virtualization in ListView/CollectionView works by combining 2 properties:\n ItemsSource: a list of raw data DataTemplate: a template object used to describe what the row should look like  Given the MVVM nature of XF, row reuse is mostly driven by bindings. DataTemplate doesn\u0026rsquo;t know about the raw data it will receive and only setups binding.\n\u0026lt;ListView ItemsSource=\u0026quot;{Binding Items}\u0026quot;\u0026gt; \u0026lt;ListView.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;TextCell Text=\u0026quot;{Binding MyProperty}\u0026quot; /\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;/ListView.ItemTemplate\u0026gt; \u0026lt;/ListView\u0026gt;  Xamarin.Forms creates a row using the DataTemplate and sets its BindingContext with the raw item. This triggers refresh of the row UI. Same on row reuse, XF sets the new raw item into BindingContext and refreshes the bindings.\nThis model doesn\u0026rsquo;t work with Fabulous at all, due to the lack of Binding. Fortunately, we can work with DataTemplateSelector to access the current item before returning the appropriate DataTemplate. This allows Fabulous to support virtualization.\nHow it works in Fabulous # Semantically speaking, our Widget is very close to DataTemplate. They both describe what a specific piece of UI should look like. The main difference is that DataTemplate doesn\u0026rsquo;t know of the data it will work with in advance, whereas Widget has been built with that data.\nSo the main challenge was to make the 2 concepts compatible.\nSimple collections (aka not grouped) # Storing data and the template function # In Fabulous v1, we were creating all ViewElement items (Widget in v2) on each view update. This can be problematic in case you have a large number of items.\nActually thanks to how virtualization works, we only need to \u0026ldquo;process\u0026rdquo; a couple of items for the visible rows. No need to go create all widgets on each view update.\nTo support that, the following type has been created:\ntype WidgetItems\u0026lt;'T\u0026gt; = { // The raw list of data provided by the user OriginalItems: IEnumerable\u0026lt;'T\u0026gt; // Function to convert one item to a widget Template: 'T -\u0026gt; Widget }  This WidgetItems is created by the function ViewHelpers.buildItems and is stored directly in the ItemsSource scalar attribute.\nlet buildItems\u0026lt;'msg, 'marker, 'itemData, 'itemMarker\u0026gt; key attrDef (items: seq\u0026lt;'itemData\u0026gt;) (itemTemplate: 'itemData -\u0026gt; WidgetBuilder\u0026lt;'msg, 'itemMarker\u0026gt;) = (...) static member inline ListView\u0026lt;'msg, 'itemData, 'itemMarker when 'itemMarker :\u0026gt; ICell\u0026gt;(items: seq\u0026lt;'itemData\u0026gt;) = ViewHelpers.buildItems\u0026lt;'msg, IListView, 'itemData, 'itemMarker\u0026gt; ViewKeys.ListView ItemsViewOfCell.ItemsSource items  Note the use of 'itemMarker to enforce the type of widget items\nKeeping the original items allows us to directly compare them on each update to determine if we need to update the UI.\n(fun (a, b) -\u0026gt; ScalarAttributeComparers.equalityCompare(a.OriginalItems, b.OriginalItems))  Currently, scalar attributes in Fabulous have 2 generic parameters: the 'inputType and 'modelType.\nThe 'inputType is what we expect the users to provide us. The 'modelType is an optimized representation of the same data (eg. 'inputType is int list, 'modelType will be int[]).\nBefore storing the attribute value, we convert 'inputType to 'modelType through the Convert function declared in the ScalarAttributeDefinition; 'inputType is never stored.\nBut the comparison function shown just above is only done between 2 'modelTypes, but ListView/CollectionView expect an IEnumerable and not a WidgetItems.\nSo to support this, we need another generic parameter 'valueType and the corresponding ConvertValue: 'modelType -\u0026gt; 'valueType function.\ntype ScalarAttributeDefinition\u0026lt;'inputType, 'modelType, 'valueType\u0026gt; = { (...) Compare: 'modelType -\u0026gt; 'modelType ConvertValue: 'modelType -\u0026gt; 'valueType }  With this, we can still store and compare WidgetItems, but when we actually need to apply the value to the XF property, we call ConvertValue to transform it. Attributes that don\u0026rsquo;t need conversion can use the id function to make it transparent.\nFor WidgetItems, we build an IEnumerable on the fly using the original items and the template function before assigning it to the XF property ItemsSource.\n(fun modelValue -\u0026gt; seq { for x in modelValue.OriginalItems do modelValue.Template x })  Now Xamarin.Forms has a list of Widgets, and thanks to seq, it will only enumerate the items it needs to display.\nLoading Widgets into rows # Unlike DataTemplate in MVVM apps, instead of setting bindings to capture the raw data inside BindingContext, we now have a Widget.\nTo make it work, we need 2 things:\n A DataTemplateSelector that will know which DataTemplate to create based on the widget A DataTemplate that will listen to BindingContextChanged and run the Reconciler when a widget is attached to the row  // IsHeader is only for grouping type WidgetDataTemplateSelector internal (node: IViewNode, itemType: VirtualizedItemType) = inherit DataTemplateSelector() /// Reuse data template for already known widget target type let cache = Dictionary\u0026lt;Type, WidgetDataTemplate\u0026gt;() override _.OnSelectTemplate(item, _) = let widget = BindableHelpers.getWidgetFromBindingContext itemType item let widgetDefinition = WidgetDefinitionStore.get widget.Key let targetType = widgetDefinition.GetTargetType(widget) match cache.TryGetValue(targetType) with | true, dataTemplate -\u0026gt; dataTemplate | false, _ -\u0026gt; let dataTemplate = WidgetDataTemplate(targetType, isHeader, node) cache.Add(targetType, dataTemplate) dataTemplate  Note that like said earlier, DataTemplate are created before knowing which value they will host. This means we can only create an empty row for now. So to enable row reuse later, we extract the root target type of a widget and create an empty row with it.\neg.\nfun item -\u0026gt; ViewCell( Grid(...) )  will have a target type of ViewCell and we create an empty ViewCell.\nSide note: Given the potential high cost of instantiate a lot of View.lazy', its use is not allowed in virtualized collections.\nThis DataTemplateSelector instantiates a WidgetDataTemplate that will create the appropriate XF control and listen to BindingContextChanged.\n/// Create a DataTemplate for a specific root type (TextCell, ViewCell, etc.) /// that listen for BindingContext change to apply the Widget content to the cell type WidgetDataTemplate(``type``, itemType, parent: IViewNode) = inherit DataTemplate(fun () -\u0026gt; let bindableObject = Activator.CreateInstance ``type`` :?\u0026gt; BindableObject let viewNode = ViewNode(ValueSome parent, parent.TreeContext, WeakReference(bindableObject)) bindableObject.SetValue(ViewNode.ViewNodeProperty, viewNode) let onBindingContextChanged = BindableHelpers.createOnBindingContextChanged parent.TreeContext.CanReuseView itemType bindableObject bindableObject.BindingContextChanged.Add (fun _ -\u0026gt; onBindingContextChanged ()) bindableObject :\u0026gt; obj )  For fresh rows, Xamarin.Forms will execute that function and then set the BindingContext with the widget from our list. When XF reuses a row, it will set the new widget in the BindingContext as well. Each time, we call the Reconciler to update the row.\nFinal step is to pass this WidgetDataTemplateSelector in the XF property ItemTemplate. Since it will never change, we assign it when creating the controls.\n/// Force ListView to recycle rows because DataTemplateSelector disables it by default, only possible in ctor /// CollectionView recycles by default type FabulousListView() = inherit ListView(ListViewCachingStrategy.RecycleElement) let ListView = Widgets.registerWithAdditionalSetup\u0026lt;FabulousListView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) ) let CollectionView = Widgets.registerWithAdditionalSetup\u0026lt;Xamarin.Forms.CollectionView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) )  A registerWithAdditionalSetup was needed because DataTemplateSelector requires access to the ViewNode of the ListView/CollectionView, and it was not possible to do it in the constructor of the controls.\nGrouped collections # Grouped ListView/CollectionView is slightly different. Instead of having a 1-dimensional enumerable of raw data, we have a 2-dimension one (eg. IEnumerable\u0026lt;IEnumerable\u0026lt;T\u0026gt;\u0026gt;)\nTo support this with everything we saw just before, GroupItem has been created.\ntype GroupItem(header: Widget, footer: Widget, source: IEnumerable\u0026lt;Widget\u0026gt;) = member _.Header = header member _.Footer = footer interface IEnumerable\u0026lt;Widget\u0026gt; with member this.GetEnumerator(): IEnumerator\u0026lt;Widget\u0026gt; = source.GetEnumerator() member this.GetEnumerator(): IEnumerator = source.GetEnumerator()  Instead of applying a list of IEnumerable\u0026lt;Widget\u0026gt; to XF property ItemsSource, we apply a list of IEnumerable\u0026lt;GroupItem\u0026gt;.\nThe builder function takes 3 template functions instead of 1: the group header template, the item template and the group footer template. All of which are called on ConvertValue to create the list of \u0026lsquo;GroupItem\u0026rsquo;.\nSince the data source is different, we need a different DataTemplate for XF properties GroupHeaderTemplate and GroupFooterTemplate. Even with grouping enabled, ItemTemplate remains a simple Widget -\u0026gt; row.\nGroupedWidgetDataTemplateSelector will either use the Header or Footer widgets to create the corresponding rows.\nAnd when registering the ListView/CollectionView types, we enable the IsGrouped flag.\nlet GroupedListView = Widgets.registerWithAdditionalSetup\u0026lt;FabulousListView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) target.GroupHeaderTemplate \u0026lt;- GroupedWidgetDataTemplateSelector(node, Header) target.IsGroupingEnabled \u0026lt;- true ) let GroupedCollectionView = Widgets.registerWithAdditionalSetup\u0026lt;Xamarin.Forms.CollectionView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) target.GroupHeaderTemplate \u0026lt;- GroupedWidgetDataTemplateSelector(node, Header) target.GroupFooterTemplate \u0026lt;- GroupedWidgetDataTemplateSelector(node, Footer) target.IsGrouped \u0026lt;- true )  "}).add({id:18,href:"https://fsprojects.github.io/Fabulous/docs/v2/api/controls/button/",title:"Button",description:"Inheritance: Element -\u0026gt; NavigableElement -\u0026gt; VisualElement -\u0026gt; View\nXamarin.Forms documentation: Button API / Guide\nFor details on how the control actually works, please refer to the Xamarin.Forms documentation.\nConstructors #    Constructors Description     Button(text: string, onClicked: \u0026lsquo;msg) Defines a Button widget with a text and clicked event    Properties #    Properties Description     textColor(light: Color, ?dark: Color) Sets the text color depending if light or dark mode   textTransform(value: TextTransform) Sets the text transformation (lowercase, uppercase) to apply on the text   cornerRadius(value: int) Sets the corner radius of the button   borderColor(light: Color, ?",content:"Inheritance: Element -\u0026gt; NavigableElement -\u0026gt; VisualElement -\u0026gt; View\nXamarin.Forms documentation: Button API / Guide\nFor details on how the control actually works, please refer to the Xamarin.Forms documentation.\nConstructors #    Constructors Description     Button(text: string, onClicked: \u0026lsquo;msg) Defines a Button widget with a text and clicked event    Properties #    Properties Description     textColor(light: Color, ?dark: Color) Sets the text color depending if light or dark mode   textTransform(value: TextTransform) Sets the text transformation (lowercase, uppercase) to apply on the text   cornerRadius(value: int) Sets the corner radius of the button   borderColor(light: Color, ?dark: Color) Sets the border color depending if light or dark mode   borderWidth(value: float) Sets the border width of the button   padding(value: float) Sets a uniform amount of padding around the button   padding(value: Thickness) Sets a uniform amount of padding around the button   padding(left: float, top: float, right: float, bottom: float) Sets the amount of padding around the button   characterSpacing(value: float) Sets the spacing between each character of the button   contentLayout(position: ImagePosition, spacing: float) Sets the position and spacing of the image in the button   font(?size: float, ?namedSize: NamedSize, ?attributes: FontAttributes, ?fontFamily: string) Sets the font family used   image(light: ImageSource, ?dark: ImageSource) Sets the image source depending if light or dark mode   image(light: string, ?dark: string) Sets the image source from a file depending if light or dark mode   image(light: Uri, ?dark: Uri) Sets the image source from an uri depending if light or dark mode   image(light: Stream, ?dark: Stream) Sets the image source from a stream depending if light or dark mode   onPressed(onPressed: \u0026lsquo;msg) Sets the event handler for the button pressed event   onReleased(onReleased: \u0026lsquo;msg) Sets the event handler for the button released event   reference(value: ViewRef\u0026lt;Button\u0026gt;) Sets a ViewRef instance to retrieve the Xamarin.Forms.Button instance associated to this widget    Events #    Properties Description     onPressed(onPressed: \u0026lsquo;msg) Sets the event handler for the button pressed event   onReleased(onReleased: \u0026lsquo;msg) Sets the event handler for the button released event    Usages # Button(\u0026quot;Press me!\u0026quot;, ClickMsg) .textColor(light = Color.Red, dark = Color.Blue) .textTransform(TextTransform.Lowercase) .cornerRadius(10) .borderColor(light = Color.Red, dark = Color.Blue) .borderWidth(2.) .padding(10.) .characterSpacing(1.) .contentLayout(ImagePosition.Left, 10.) .image(light = \u0026quot;icon.png\u0026quot;, dark = \u0026quot;icon.png\u0026quot;) .font(namedSize = NamedSize.Large, fontFamily = \u0026quot;Arial\u0026quot;, attributes = FontAttributes.Bold) .onPressed(PressedMsg) .onReleased(ReleasedMsg)  Get access to the underlying Xamarin.Forms.Label # let buttonRef = ViewRef\u0026lt;Button\u0026gt;() Button(\u0026quot;Press me!\u0026quot;, ClickMsg) .reference(buttonRef)  "}).add({id:19,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/activityindicator/",title:"ActivityIndicator",description:"Basic example # View.ActivityIndicator(isRunning = true)  Basic example with styling # View.ActivityIndicator( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, isRunning = true )  See also:\n ActivityIndicator in Xamarin Forms Xamarin.Forms.ActivityIndicator  More examples # A simple ActivityIndicator is as follows:\nView.ActivityIndicator( isRunning = (count \u0026gt; 0) )  ",content:"Basic example # View.ActivityIndicator(isRunning = true)  Basic example with styling # View.ActivityIndicator( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, isRunning = true )  See also:\n ActivityIndicator in Xamarin Forms Xamarin.Forms.ActivityIndicator  More examples # A simple ActivityIndicator is as follows:\nView.ActivityIndicator( isRunning = (count \u0026gt; 0) )  "}).add({id:20,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/animations/",title:"Animations",description:"Animations and focus are specified by accessing the underlying Xamarin.Forms control and using Xamarin.Forms animation specifications. The underlying control is usually accessed via a ViewRef, akin to a ref in HTML/JavaScript and React.\n  A ViewRef must have a sufficient scope that it lives long enough, e.g. a global scope or the scope of the model. The ViewRef can be held in the model itself if necessary.\n  Initially ViewRef are empty.",content:"Animations and focus are specified by accessing the underlying Xamarin.Forms control and using Xamarin.Forms animation specifications. The underlying control is usually accessed via a ViewRef, akin to a ref in HTML/JavaScript and React.\n  A ViewRef must have a sufficient scope that it lives long enough, e.g. a global scope or the scope of the model. The ViewRef can be held in the model itself if necessary.\n  Initially ViewRef are empty. They will only be populated after the view function has been called and its results applied to the visual display.\n  For example, the following shows the creation of a ViewRef and associating it with a particular element:\nlet animatedLabelRef = ViewRef\u0026lt;Label\u0026gt;() let view dispatch model = View.Label(text=\u0026quot;Rotate\u0026quot;, ref=animatedLabelRef)  The underlying control can also be accessed by using the created handler:\nlet mutable label = None View.Label(text=\u0026quot;hello\u0026quot;, created=(fun l -\u0026gt; label \u0026lt;- Some l))   NOTE: A ViewRef only holds a weak handle to the underlying control.\nThe Value property may thus fail if the underlying control has been collected.\nAs a result it is often sensible to use the TryValue property which returns an option.\n Animations # Animations are specified by using a Xamarin.Forms animation specification on the underlying control, e.g.\nlet animatedLabelRef = ViewRef\u0026lt;Label\u0026gt;() let update msg model = match msg with | Poked -\u0026gt; match animatedLabelRef.TryValue with | None -\u0026gt; () | Some c -\u0026gt; c.RotateTo (360.0, 2000u) |\u0026gt; ignore let view dispatch model = View.StackLayout [ View.Label(text=\u0026quot;Rotate\u0026quot;, ref=animatedLabelRef) View.Button(text=\u0026quot;Rotate\u0026quot;, command=(fun () -\u0026gt; dispatch Poked)) ]  Animations in Xamarin.Forms specify tasks. These are ignorable if the animation is simple. Composite animations must compose tasks, either by using async { ...} and Async.AwaitTask and Async.StartAsTask, or by using task { ... } from the F# community TaskBuilder library.\nExamples of custom tasks are shown in C# syntax in Animation in Xamarin.Forms.\nSee also\n Animation in Xamarin.Forms Simple Animations in Xamarin.Forms Easing Functions in Xamarin.Forms Custom Animations in Xamarin.Forms  Focus # ViewRefs can be used to give focus to particular elements using .Focus().\nSee also\n VisualElement.Focus Method  "}).add({id:21,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/boxview/",title:"BoxView",description:"Basic example # View.BoxView()  Basic example with styling # View.BoxView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor )  See also:\n BoxView in Xamarin Forms Xamarin.Forms.BoxView  More examples # An example BoxView is as follows:\nView.BoxView( color = Color.CornflowerBlue, cornerRadius = CornerRadius 10., horizontalOptions = LayoutOptions.Center )  ",content:"Basic example # View.BoxView()  Basic example with styling # View.BoxView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor )  See also:\n BoxView in Xamarin Forms Xamarin.Forms.BoxView  More examples # An example BoxView is as follows:\nView.BoxView( color = Color.CornflowerBlue, cornerRadius = CornerRadius 10., horizontalOptions = LayoutOptions.Center )  "}).add({id:22,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/button/",title:"Button",description:"Basic example # View.Button(\u0026quot;Button\u0026quot;)  Basic example with styling # View.Button( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ButtonColor, padding = style.Padding, text = \u0026quot;Button\u0026quot; )  See also:\n Button in Xamarin Forms Xamarin.Forms.Button  More examples # Buttons are created using View.Button. The command of a button will normally dispatch a messsage. For example:\nView.Button( text = \u0026quot;Deposit\u0026quot;, command = (fun () -\u0026gt; dispatch (Add 10.0)) )  ",content:"Basic example # View.Button(\u0026quot;Button\u0026quot;)  Basic example with styling # View.Button( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ButtonColor, padding = style.Padding, text = \u0026quot;Button\u0026quot; )  See also:\n Button in Xamarin Forms Xamarin.Forms.Button  More examples # Buttons are created using View.Button. The command of a button will normally dispatch a messsage. For example:\nView.Button( text = \u0026quot;Deposit\u0026quot;, command = (fun () -\u0026gt; dispatch (Add 10.0)) )  "}).add({id:23,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/carouselpage/",title:"CarouselPage",description:"Basic example # View.CarouselPage( children = [ View.ContentPage( title =\u0026quot;carousel1\u0026quot;, content = View.Label(\u0026quot;carousel page 1\u0026quot;) ) View.ContentPage( title =\u0026quot;carousel2\u0026quot;, content = View.Label(\u0026quot;carousel page 2\u0026quot;) ) ] )  Basic example with styling # View.CarouselPage( backgroundColor = style.PageColor, title = \u0026quot;CarouselPage\u0026quot;, children = [ View.ContentPage( title =\u0026quot;carousel1\u0026quot;, content = View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;carousel page 1\u0026quot; ) ) View.ContentPage( title =\u0026quot;carousel1\u0026quot;, content = View.",content:"Basic example # View.CarouselPage( children = [ View.ContentPage( title =\u0026quot;carousel1\u0026quot;, content = View.Label(\u0026quot;carousel page 1\u0026quot;) ) View.ContentPage( title =\u0026quot;carousel2\u0026quot;, content = View.Label(\u0026quot;carousel page 2\u0026quot;) ) ] )  Basic example with styling # View.CarouselPage( backgroundColor = style.PageColor, title = \u0026quot;CarouselPage\u0026quot;, children = [ View.ContentPage( title =\u0026quot;carousel1\u0026quot;, content = View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;carousel page 1\u0026quot; ) ) View.ContentPage( title =\u0026quot;carousel1\u0026quot;, content = View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;carousel page 2\u0026quot; ) ) ] )  See also:\n Xamarin.Forms.CarouselPage  "}).add({id:24,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/carouselview/",title:"CarouselView",description:"Basic example # View.CarouselView([ View.Label(\u0026quot;First CarouselView\u0026quot;) View.Label(\u0026quot;Second CarouselView\u0026quot;) View.Label(\u0026quot;Third CarouselView\u0026quot;) ])  Basic example with styling # View.CarouselView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, items = [ View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;First CarouselView\u0026quot; ) View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor2, padding = style.Padding, text = \u0026quot;Second CarouselView\u0026quot; ) View.Label( horizontalOptions = style.Position, verticalOptions = style.",content:"Basic example # View.CarouselView([ View.Label(\u0026quot;First CarouselView\u0026quot;) View.Label(\u0026quot;Second CarouselView\u0026quot;) View.Label(\u0026quot;Third CarouselView\u0026quot;) ])  Basic example with styling # View.CarouselView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, items = [ View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;First CarouselView\u0026quot; ) View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor2, padding = style.Padding, text = \u0026quot;Second CarouselView\u0026quot; ) View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor3, padding = style.Padding, text = \u0026quot;Third CarouselView\u0026quot; ) ] )  See also:\n CarouselView in Xamarin Forms Xamarin.Forms.CarouselView  "}).add({id:25,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/checkbox/",title:"Checkbox",description:"Basic example # View.CheckBox(true)  Basic example with styling # View.CheckBox( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, isChecked = true )  See also:\n Xamarin.Forms.CheckBox  More examples # View.CheckBox( isChecked = true, checkedChanged = (fun on -\u0026gt; dispatch (...)) )  ",content:"Basic example # View.CheckBox(true)  Basic example with styling # View.CheckBox( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, isChecked = true )  See also:\n Xamarin.Forms.CheckBox  More examples # View.CheckBox( isChecked = true, checkedChanged = (fun on -\u0026gt; dispatch (...)) )  "}).add({id:26,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/collectionview/",title:"CollectionView",description:"displays a scrollable list of selectable data items, using different layout specifications\nPlease read the Xamarin.Forms documentation to check whether this control is available for the platforms you target.\nBasic example # View.CollectionView([ View.Label(\u0026quot;First CollectionView\u0026quot;) View.Label(\u0026quot;Second CollectionView\u0026quot;) View.Label(\u0026quot;Third CollectionView\u0026quot;) ])  Basic example with styling # View.CollectionView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, items = [ View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.",content:"displays a scrollable list of selectable data items, using different layout specifications\nPlease read the Xamarin.Forms documentation to check whether this control is available for the platforms you target.\nBasic example # View.CollectionView([ View.Label(\u0026quot;First CollectionView\u0026quot;) View.Label(\u0026quot;Second CollectionView\u0026quot;) View.Label(\u0026quot;Third CollectionView\u0026quot;) ])  Basic example with styling # View.CollectionView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, items = [ View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;First CollectionView\u0026quot; ) View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor2, padding = style.Padding, text = \u0026quot;Second CollectionView\u0026quot; ) View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor3, padding = style.Padding, text = \u0026quot;Third CollectionView\u0026quot; ) ] )  See also:\n CollectionView in Xamarin Forms Xamarin.Forms.CollectionView  More examples # "}).add({id:27,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/contentpage/",title:"ContentPage",description:"Basic example # A single page app typically returns a ContentPage. For example:\nView.ContentPage( title = \u0026quot;ContentPage\u0026quot;, content = View.Label(\u0026quot;ContentPage with a single Label\u0026quot;) )  Basic example with styling # View.ContentPage( backgroundColor = style.PageColor, title = \u0026quot;ContentPage\u0026quot;, content = View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;ContentPage with a single Label\u0026quot; ) )  See also:\n Xamarin.Forms.ContentPage  ",content:"Basic example # A single page app typically returns a ContentPage. For example:\nView.ContentPage( title = \u0026quot;ContentPage\u0026quot;, content = View.Label(\u0026quot;ContentPage with a single Label\u0026quot;) )  Basic example with styling # View.ContentPage( backgroundColor = style.PageColor, title = \u0026quot;ContentPage\u0026quot;, content = View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;ContentPage with a single Label\u0026quot; ) )  See also:\n Xamarin.Forms.ContentPage  "}).add({id:28,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/custom-renderer/",title:"Custom renderers and Custom controls",description:"Custom renderers # In Xamarin.Forms, custom renderers define how a control is rendered on the UI, and are specific to a platform (iOS, Android, etc.).\nFor example, the default iOSButtonRenderer will render a Xamarin.Forms.Button as a UIKit.UIButton and will handle all the properties such as Text, Color, etc.\nCustom renderers are renderers you create to either change the default behavior of an existing renderer or create a completely new one.",content:"Custom renderers # In Xamarin.Forms, custom renderers define how a control is rendered on the UI, and are specific to a platform (iOS, Android, etc.).\nFor example, the default iOSButtonRenderer will render a Xamarin.Forms.Button as a UIKit.UIButton and will handle all the properties such as Text, Color, etc.\nCustom renderers are renderers you create to either change the default behavior of an existing renderer or create a completely new one.\nWith Fabulous for Xamarin.Forms, you can still use custom renderers like you would in plain Xamarin.Forms.\nPlease read the custom renderer official documentation to learn more about them.\nHere\u0026rsquo;s an example of a custom renderer for displaying a Label with underlined text, which is not supported by Xamarin.Forms but the native platforms can do it:\n UnderlinedLabel UnderlinedLabelRenderer - iOS UnderlinedLabelRenderer - Android  Custom controls # In Xamarin.Forms, custom controls are controls that not part of the default controls of Xamarin.Forms.\nThey can either be extended controls (like the UnderlinedLabel above) or brand new ones.\nThose custom controls necessarily have custom renderers attached to them, because Xamarin.Forms doesn\u0026rsquo;t know how to render them by default.\nWhen using with Fabulous, you\u0026rsquo;ll need to both create the control class and its wrapper for Fabulous.\nHere\u0026rsquo;s an example where we extend the Xamarin.Forms Entry control to add a BorderColor property:\ntype BorderedEntry() = inherit Xamarin.Forms.Entry() static let borderColorProperty = BindableProperty.Create(\u0026quot;BorderColor\u0026quot;, typeof\u0026lt;Color\u0026gt;, typeof\u0026lt;BorderedEntry\u0026gt;, Color.Default) member this.BorderColor with get () = this.GetValue(borderColorProperty) :?\u0026gt; Color and set (value) = this.SetValue(borderColorProperty, value)  Along with this control, we create the wrapper (like defined in the View Extensions documentation) so we can use it in our Fabulous application:\n[\u0026lt;AutoOpen\u0026gt;] module FabulousBorderedEntry = let BorderedEntryBorderColorAttributeKey = AttributeKey\u0026lt;_\u0026gt; \u0026quot;BorderedEntry_BorderColor\u0026quot; type Fabulous.XamarinForms.View with static member inline BorderedEntry(?borderColor: Color, ?placeholder, ?text, ?textChanged, ?keyboard) = let attribCount = match borderColor with None -\u0026gt; 0 | Some _ -\u0026gt; 1 let attribs = ViewBuilders.BuildEntry(attribCount, ?placeholder = placeholder, ?text = text, ?textChanged = textChanged, ?keyboard = keyboard) match borderColor with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(BorderedEntryBorderColorAttributeKey, v) let update (prevOpt: ViewElement voption) (source: ViewElement) (target: BorderedEntry) = ViewBuilders.UpdateEntry(prevOpt, source, target) source.UpdatePrimitive(prevOpt, target, BorderedEntryBorderColorAttributeKey, (fun target v -\u0026gt; target.BorderColor \u0026lt;- v)) let updateAttachedProperties propertyKey prevOpt source target = ViewBuilders.UpdateEntryAttachedProperties(propertyKey, prevOpt, source, target) ViewElement.Create(BorderedEntry, update, updateAttachedProperties, attribs)  Once this is done, we\u0026rsquo;ll need a custom renderer per platform for that control to handle the new BorderColor property.\nHere\u0026rsquo;s the example for iOS:\ntype BorderedEntryRenderer() = inherit EntryRenderer() member this.BorderedEntry with get() = this.Element :?\u0026gt; FabulousContacts.Controls.BorderedEntry override this.OnElementChanged(e) = base.OnElementChanged(e) if (e.NewElement \u0026lt;\u0026gt; null) then this.Control.Layer.BorderColor \u0026lt;- this.BorderedEntry.BorderColor.ToCGColor() this.Control.Layer.BorderWidth \u0026lt;- nfloat 1. this.Control.Layer.CornerRadius \u0026lt;- nfloat 5. else () override this.OnElementPropertyChanged(_, e) = if e.PropertyName = \u0026quot;BorderColor\u0026quot; then this.Control.Layer.BorderColor \u0026lt;- this.BorderedEntry.BorderColor.ToCGColor() this.Control.Layer.BorderWidth \u0026lt;- nfloat 1. this.Control.Layer.CornerRadius \u0026lt;- nfloat 5. /// This dummy module is required by F# to be able to use [\u0026lt;assembly:ExportRendererAttribute\u0026gt;] /// so Xamarin.Forms can find your custom renderer module Dummy_BorderedEntryRenderer = [\u0026lt;assembly: Xamarin.Forms.ExportRenderer(typeof\u0026lt;FabulousContacts.Controls.BorderedEntry\u0026gt;, typeof\u0026lt;BorderedEntryRenderer\u0026gt;)\u0026gt;] do ()  Complete example:\n BorderedEntry BorderedEntryRenderer - iOS BorderedEntryRenderer - Android  See also:\n Xamarin.Forms - Custom Renderer Xamarin.Forms - Introduction to Custom Renderers Xamarin.Forms - Renderer List  "}).add({id:29,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/datepicker/",title:"DatePicker",description:"Basic example # View.DatePicker()  Basic example with styling # View.DatePicker( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor )  See also:\n Xamarin.Forms.DatePicker  More examples # View.DatePicker( minimumDate = DateTime.Today, maximumDate = DateTime.Today + TimeSpan.FromDays(365.0), date = startDate, dateSelected = (fun args -\u0026gt; dispatch (StartDateSelected args.NewDate)) )  ",content:"Basic example # View.DatePicker()  Basic example with styling # View.DatePicker( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor )  See also:\n Xamarin.Forms.DatePicker  More examples # View.DatePicker( minimumDate = DateTime.Today, maximumDate = DateTime.Today + TimeSpan.FromDays(365.0), date = startDate, dateSelected = (fun args -\u0026gt; dispatch (StartDateSelected args.NewDate)) )  "}).add({id:30,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/editor/",title:"Editor",description:"Basic example # View.Editor(\u0026quot;Editor\u0026quot;)  Basic example with styling # View.Editor( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, text = \u0026quot;Editor\u0026quot; )  See also:\n Editor in Xamarin Forms Xamarin.Forms.Editor  More examples # An example Editor is as follows:\nView.Editor( text = editorText, textChanged = (fun args -\u0026gt; dispatch (TextChanged(args.OldTextValue, args.NewTextValue))), completed = (fun text -\u0026gt; dispatch (EditorEditCompleted text)) )  ",content:"Basic example # View.Editor(\u0026quot;Editor\u0026quot;)  Basic example with styling # View.Editor( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, text = \u0026quot;Editor\u0026quot; )  See also:\n Editor in Xamarin Forms Xamarin.Forms.Editor  More examples # An example Editor is as follows:\nView.Editor( text = editorText, textChanged = (fun args -\u0026gt; dispatch (TextChanged(args.OldTextValue, args.NewTextValue))), completed = (fun text -\u0026gt; dispatch (EditorEditCompleted text)) )  "}).add({id:31,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/effects/",title:"Effects",description:"Xamarin.Forms user interfaces are rendered using the native controls of the target platform, allowing Xamarin.Forms applications to retain the appropriate look and feel for each platform. Effects allow the native controls on each platform to be customized without having to resort to a custom renderer implementation.\nUsing Effects in Fabulous.XamarinForms # The recommended way to use an effect in Fabulous is by using the dedicated View.Effect.\nThis control accepts the effect\u0026rsquo;s exported full name (\u0026quot;SomeResolutionGroup.",content:"Xamarin.Forms user interfaces are rendered using the native controls of the target platform, allowing Xamarin.Forms applications to retain the appropriate look and feel for each platform. Effects allow the native controls on each platform to be customized without having to resort to a custom renderer implementation.\nUsing Effects in Fabulous.XamarinForms # The recommended way to use an effect in Fabulous is by using the dedicated View.Effect.\nThis control accepts the effect\u0026rsquo;s exported full name (\u0026quot;SomeResolutionGroup.SomeEffectName\u0026quot;) and it can be attached to any control with the effects properties.\nView.Button(effects = [ View.Effect(name = \u0026quot;SomeResolutionGroup.SomeEffectName\u0026quot;) ])  This way is only suitable if your effect doesn\u0026rsquo;t need any external values.\nCreate wrapper for custom effects with properties # If you want to use your own effects with properties in Fabulous.XamarinForms, you will need to write an extension.\nFor more information, please read about View Extensions\nLet\u0026rsquo;s take this ShadowEffect for example:\nopen Xamarin.Forms type ShadowEffect() = inherit RoutingEffect(\u0026quot;FabulousXamarinForms.ShadowEffect\u0026quot;) member val Radius = 0. with get, set member val Color = Color.Default with get, set member val DistanceX = 0. with get, set member val DistanceY = 0. with get, set  If we want to use it in our views, we will need to write the following extension:\n[\u0026lt;AutoOpen\u0026gt;] module ShadowEffectViewExtension = open Fabulous open Fabulous.XamarinForms let RadiusAttribKey = AttributeKey \u0026quot;ShadowEffectRadius\u0026quot; let ColorAttribKey = AttributeKey \u0026quot;ShadowEffectColor\u0026quot; let DistanceXAttribKey = AttributeKey \u0026quot;ShadowEffectDistanceX\u0026quot; let DistanceYAttribKey = AttributeKey \u0026quot;ShadowEffectDistanceY\u0026quot; type Fabulous.XamarinForms.View with static member inline ShadowEffect(?radius, ?color, ?distanceX, ?distanceY) = let attribCount = 0 let attribCount = match radius with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match color with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match distanceX with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match distanceY with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribs = AttributesBuilder(attribCount) match radius with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(RadiusAttribKey, v) match color with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(ColorAttribKey, v) match distanceX with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(DistanceXAttribKey, v) match distanceY with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(DistanceYAttribKey, v) let create () = ShadowEffect() let update (prevOpt: ViewElement voption) (source: ViewElement) (target: ShadowEffect) = source.UpdatePrimitive(prevOpt, target, RadiusAttribKey, (fun target v -\u0026gt; target.Radius \u0026lt;- v)) source.UpdatePrimitive(prevOpt, target, ColorAttribKey, (fun target v -\u0026gt; target.Color \u0026lt;- v)) source.UpdatePrimitive(prevOpt, target, DistanceXAttribKey, (fun target v -\u0026gt; target.DistanceX \u0026lt;- v)) source.UpdatePrimitive(prevOpt, target, DistanceYAttribKey, (fun target v -\u0026gt; target.DistanceY \u0026lt;- v)) ViewElement.Create(create, update, attribs)  This then enables us to use it like this:\nView.Label(effects = [ View.ShadowEffect(color = Color.Black, radius = 5.) ])  Alternatively you can do it without an extension, and use both the created event and the Effects collection of the Xamarin.Forms control.\nView.Label(created = fun e -\u0026gt; let effect = new ShadowEffect() effect.Color \u0026lt;- Color.Black effect.Radius \u0026lt;- 5. e.Effects.Add effect )  This way is not recommended because it can\u0026rsquo;t make use of the incremental update mecanism.\nSee also:\n Xamarin.Forms - Effects Xamarin.Forms - Creating an Effect Xamarin.Forms - Introduction to Effects  "}).add({id:32,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/ellipse/",title:"Ellipse",description:"Basic example # View.Ellipse( fill = View.SolidColorBrush(Color.Black), width = 50., height = 50. )  Basic example with styling # View.Ellipse( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, fill = View.SolidColorBrush(Color.Black), width = 50., height = 50. )  See also:\n Ellipse in Xamarin Forms Xamarin.Forms.Ellipse  More examples # Ellipse can be used to draw ellipses and circles.\nView.Ellipse( width = 50., height = 50., fill = View.",content:"Basic example # View.Ellipse( fill = View.SolidColorBrush(Color.Black), width = 50., height = 50. )  Basic example with styling # View.Ellipse( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, fill = View.SolidColorBrush(Color.Black), width = 50., height = 50. )  See also:\n Ellipse in Xamarin Forms Xamarin.Forms.Ellipse  More examples # Ellipse can be used to draw ellipses and circles.\nView.Ellipse( width = 50., height = 50., fill = View.SolidColorBrush(Color.Orange), horizontalOptions = LayoutOptions.Center )  "}).add({id:33,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/entry/",title:"Entry",description:"Basic example # View.Entry(\u0026quot;Entry\u0026quot;)  Basic example with styling # View.Entry( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, text = \u0026quot;Entry\u0026quot; )  See also:\n Entry in Xamarin Forms Xamarin.Forms.  More examples # An example Entry is as follows:\nView.Entry( text = entryText, textChanged = (fun args -\u0026gt; dispatch (TextChanged(args.OldTextValue, args.NewTextValue))), completed = (fun text -\u0026gt; dispatch (EntryEditCompleted text)) )  An example Entry with password is as follows:",content:"Basic example # View.Entry(\u0026quot;Entry\u0026quot;)  Basic example with styling # View.Entry( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, text = \u0026quot;Entry\u0026quot; )  See also:\n Entry in Xamarin Forms Xamarin.Forms.  More examples # An example Entry is as follows:\nView.Entry( text = entryText, textChanged = (fun args -\u0026gt; dispatch (TextChanged(args.OldTextValue, args.NewTextValue))), completed = (fun text -\u0026gt; dispatch (EntryEditCompleted text)) )  An example Entry with password is as follows:\nView.Entry( text = password, isPassword = true, textChanged = (fun args -\u0026gt; dispatch (TextChanged(args.OldTextValue, args.NewTextValue))), completed = (fun text -\u0026gt; dispatch (EntryEditCompleted text)) )  An example Entry with a placeholder is as follows:\nView.Entry( placeholder = \u0026quot;Enter text\u0026quot;, textChanged = (fun args -\u0026gt; dispatch (TextChanged(args.OldTextValue, args.NewTextValue))), completed = (fun text -\u0026gt; dispatch (EntryEditCompleted text)) )  "}).add({id:34,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/codegen-bindings/",title:"Fabulous.CodeGen",description:"Root # { \u0026quot;assemblies\u0026quot;: [ \u0026quot;path/to/A.dll\u0026quot;, \u0026quot;path/to/B.dll\u0026quot; ], \u0026quot;outputNamespace\u0026quot;: \u0026quot;My.Namespace\u0026quot;, \u0026quot;types\u0026quot;: [ // See Type ] }     Field Type Required Description     Assemblies string array ✅ Yes Paths to dlls containing controls (can be relative to working directory)   OutputNamespace string ✅ Yes Namespace under which all the generated code will be added   Types Type array ✅ Yes All types to bind    Type # { \u0026quot;type\u0026quot;: \u0026quot;Xamarin.",content:"Root # { \u0026quot;assemblies\u0026quot;: [ \u0026quot;path/to/A.dll\u0026quot;, \u0026quot;path/to/B.dll\u0026quot; ], \u0026quot;outputNamespace\u0026quot;: \u0026quot;My.Namespace\u0026quot;, \u0026quot;types\u0026quot;: [ // See Type ] }     Field Type Required Description     Assemblies string array ✅ Yes Paths to dlls containing controls (can be relative to working directory)   OutputNamespace string ✅ Yes Namespace under which all the generated code will be added   Types Type array ✅ Yes All types to bind    Type # { \u0026quot;type\u0026quot;: \u0026quot;Xamarin.Forms.ListView\u0026quot;, \u0026quot;customType\u0026quot;: \u0026quot;Fabulous.XamarinForms.CustomListView\u0026quot;, \u0026quot;canBeInstantiated\u0026quot;: true, \u0026quot;name\u0026quot;: \u0026quot;ListView\u0026quot;, \u0026quot;properties\u0026quot;: [ // See Property ], \u0026quot;events\u0026quot;: [ // See Event ], \u0026quot;attachedProperties\u0026quot;: [ // See Attached Property ] }     Field Type Required Description     Type string ✅ Yes Full name of a control inside one of the dlls to bind   CustomType string ❌ No If specified, this type will be used when instantiating this control instead of the binded type. Not necessary that the control exists at generation time   CanBeInstantiated boolean ❌ No Indicates if the code generator should provide a public constructor for this type. If not specified, the value defaults to true   Name boolean ❌ No The name that will be used when generating code (e.g. View.MyCustomControl()). If not specified, the name will be inferred from the Type field   Properties Property array ❌ No All properties of this control to include in the code generation   Events Event array ❌ No All events of this control to include in the code generation   AttachedProperties AttachedProperty array ❌ No All attached properties of this control to include in the code generation    Property # { \u0026quot;source\u0026quot;: \u0026quot;Source\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Name\u0026quot;, \u0026quot;uniqueName\u0026quot;: \u0026quot;UniqueName\u0026quot;, \u0026quot;shortName\u0026quot;: \u0026quot;shortName\u0026quot;, \u0026quot;defaultValue\u0026quot;: \u0026quot;DefaultValue\u0026quot;, \u0026quot;elementType\u0026quot;: \u0026quot;ElementType\u0026quot;, \u0026quot;inputType\u0026quot;: \u0026quot;InputType\u0026quot;, \u0026quot;modelType\u0026quot;: \u0026quot;ModelType\u0026quot;, \u0026quot;convertInputToModel\u0026quot;: \u0026quot;(fun input: InputType -\u0026gt; input :?\u0026gt; ModelType)\u0026quot;, \u0026quot;convertModelToValue\u0026quot;: \u0026quot;(fun model: ModelType-\u0026gt; model :?\u0026gt; ValueType)\u0026quot;, \u0026quot;updateCode\u0026quot;: \u0026quot;(fun prev curr target -\u0026gt; ())\u0026quot; }     Field Type Required Description Remarks     Source string ❓Depends Name of the property to include (and overwrite)    Name string ❓Depends Name of the property used in the generated code (e.g. buttonViewElement.MyProperty(value)) If not specified, Source will be used instead   UniqueName string ❌ No Name to uniquely identify the property in the generated code Use with caution. If not specified, Type and Name will be concatenated to create a unique name. (e.g. ButtonText). Subject to optimization   ShortName string ❌ No Name (lower camel case) to use in ViewElement constructor (e.g. View.Button(myProperty=value)) If not specified, Name will be used in lower camel case   DefaultValue string ❓Depends Default value to apply to the property if none is given by the user (e.g. 0.0f)    ElementType string ❓Depends (Apply only if property is a collection) Full name of the item type of the collection If null, the property is not considered to be a collection   InputType string ❓Depends Type expected in the constructor (e.g. string =\u0026gt; View.Button(text = \u0026quot;some string\u0026quot;))    ModelType string ❌ No Type as which the value will be stored in the ViewElement attributes dictionary Make sure this type is efficient   ConvertInputToModel string ❌ No Function to convert the input value to the model type Expects a signature of type 'Input -\u0026gt; 'Model. Function can be written directly inside the json, or make a reference to a function. If not specified, no conversion will be applied.   ConvertModelToValue string ❌ No Function to convert the model value to the expected type of the real property Expects a signature of type 'Model -\u0026gt; 'Value. Function can be written directly inside the json, or make a reference to a function. If not specified, no conversion will be applied.   UpdateCode string ❌ No Function to use instead of the generated view diffing for this property Expects a signature of type prev: ViewElement -\u0026gt; curr: ViewElement -\u0026gt; target: ControlType -\u0026gt; unit. Function can be written directly inside the json, or make a reference to a function. If not specified, the default view diffing code will be used.    There is 3 different categories of property:\n Existing scalar property: A property present in one of the dlls to include with a simple data type Existing collection property: A property present in one of the dlls to include which is a collection (e.g. Xamarin.Forms.View list) Dummy property: A non-existent property to include which can be either of type scalar or collection  See examples for these categories below.\nEvent # { \u0026quot;source\u0026quot;: \u0026quot;TextChanged\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;TextChanged\u0026quot;, \u0026quot;uniqueName\u0026quot;: \u0026quot;EntryTextChanged\u0026quot;, \u0026quot;shortName\u0026quot;: \u0026quot;textChanged\u0026quot;, \u0026quot;inputType\u0026quot;: \u0026quot;Xamarin.Forms.TextChangedEventArgs -\u0026gt; unit\u0026quot;, \u0026quot;modelType\u0026quot;: \u0026quot;System.EventHandler\u0026lt;Xamarin.Forms.TextChangedEventArgs\u0026gt;\u0026quot;, \u0026quot;convertInputToModel\u0026quot;: \u0026quot;(fun f -\u0026gt; System.EventHandler\u0026lt;Xamarin.Forms.TextChangedEventArgs\u0026gt;(fun _sender _args -\u0026gt; f args))\u0026quot; }     Field Type Required Description Remarks     Source string ❓Depends Name of the event to include (and overwrite)    Name string ❓Depends Name of the event used in the generated code (e.g. entryViewElement.TextChanged(value)) If not specified, Source will be used instead   UniqueName string ❌ No Name to uniquely identify the event in the generated code Use with caution. If not specified, Type and Name will be concatenated to create a unique name. (e.g. EntryTextChanged). Subject to optimization   ShortName string ❌ No Name (lower camel case) to use in ViewElement constructor (e.g. View.Button(myProperty=value)) If not specified, Name will be used in lower camel case   InputType string ❓Depends Type expected in the constructor (e.g. Xamarin.Forms.TextChangedEventArgs -\u0026gt; unit =\u0026gt; View.Button(textChanged = (fun args -\u0026gt; ()))) Expects a function   ModelType string ❓Depends Type as which the value will be stored in the ViewElement attributes dictionary Expects an EventHandler   ConvertInputToModel string ❓Depends Function to convert the input value to the model type Expects a signature of type 'Input -\u0026gt; 'Model. Function can be written directly inside the json, or make a reference to a function. If not specified, no conversion will be applied.    AttachedProperty # { \u0026quot;source\u0026quot;: \u0026quot;Source\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Name\u0026quot;, \u0026quot;uniqueName\u0026quot;: \u0026quot;UniqueName\u0026quot;, \u0026quot;defaultValue\u0026quot;: \u0026quot;DefaultValue\u0026quot;, \u0026quot;elementType\u0026quot;: \u0026quot;ElementType\u0026quot;, \u0026quot;inputType\u0026quot;: \u0026quot;InputType\u0026quot;, \u0026quot;modelType\u0026quot;: \u0026quot;ModelType\u0026quot;, \u0026quot;convertInputToModel\u0026quot;: \u0026quot;(fun input -\u0026gt; input :?\u0026gt; Model)\u0026quot;, \u0026quot;convertModelToValue\u0026quot;: \u0026quot;(fun model -\u0026gt; model :?\u0026gt; Value)\u0026quot;, \u0026quot;updateCode\u0026quot;: \u0026quot;(fun prev curr target -\u0026gt; ())\u0026quot; }     Field Type Required Description Remarks     Source string ❓ Depends Name of the attached property to include (and overwrite)    TargetType string ❌ No Type to which this attached property will be applied to If not specified, a default base target type will be applied   Name string ❓ Depends Name of the property used in the generated code (e.g. buttonViewElement.MyProperty(value)) If not specified, Source will be used instead   UniqueName string ❌ No Name to uniquely identify the property in the generated code Use with caution. If not specified, Type and Name will be concatenated to create a unique name. (e.g. ButtonText). Subject to optimization   DefaultValue string ❓ Depends Default value to apply to the property if none is given by the user (e.g. 0.0f) If not specified, Name will be used in lower camel case   ElementType string ❓ Depends (Apply only if attached property is a collection) Full name of the item type of the collection If null, the attached property is not considered to be a collection   InputType string ❓ Depends Type expected in the constructor (e.g. string =\u0026gt; View.Button(text = \u0026quot;some string\u0026quot;))    ModelType string ❌ No Type as which the value will be stored in the ViewElement attributes dictionary Make sure this type is efficient   ConvertInputToModel string ❌ No Function to convert the input value to the model type Expects a signature of type 'Input -\u0026gt; 'Model. Function can be written directly inside the json, or make a reference to a function. If not specified, no conversion will be applied.   ConvertModelToValue string ❌ No Function to convert the model value to the expected type of the real property Expects a signature of type 'Model -\u0026gt; 'Value. Function can be written directly inside the json, or make a reference to a function. If not specified, no conversion will be applied.   UpdateCode string ❌ No Function to use instead of the generated view diffing for this property Expects a signature of type prev: ViewElement -\u0026gt; curr: ViewElement -\u0026gt; target: ControlType -\u0026gt; unit. Function can be written directly inside the json, or make a reference to a function. If not specified, the default view diffing code will be used.    Examples # Example properties # Existing scalar property # { \u0026quot;source\u0026quot;: \u0026quot;Margin\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Margin\u0026quot;, \u0026quot;uniqueName\u0026quot;: \u0026quot;VisualElementMargin\u0026quot;, \u0026quot;shortName\u0026quot;: \u0026quot;margin\u0026quot;, \u0026quot;inputType\u0026quot;: \u0026quot;InputTypes.Thickness\u0026quot;, \u0026quot;modelType\u0026quot;: \u0026quot;Thickness\u0026quot;, \u0026quot;convertInputToModel\u0026quot;: \u0026quot;ViewConverters.convertThickness\u0026quot;, \u0026quot;convertModelToValue\u0026quot;: null }     Field Type Required     Source string ✅ Yes   Name string ❌ No   UniqueName string ❌ No   ShortName string ❌ No   InputType string ❌ No   ModelType string ❌ No   ConvertInputToModel string ❌ No   ConvertModelToValue string ❌ No   UpdateCode string ❌ No    Existing collection property # { \u0026quot;source\u0026quot;: \u0026quot;ItemsSource\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Items\u0026quot;, \u0026quot;uniqueName\u0026quot;: \u0026quot;GridItems\u0026quot;, \u0026quot;shortName\u0026quot;: \u0026quot;items\u0026quot;, \u0026quot;elementType\u0026quot;: \u0026quot;Xamarin.Forms.View\u0026quot;, \u0026quot;inputType\u0026quot;: \u0026quot;ViewElement list\u0026quot;, \u0026quot;modelType\u0026quot;: \u0026quot;ViewElement array\u0026quot;, \u0026quot;convertInputToModel\u0026quot;: \u0026quot;Array.ofList\u0026quot; }     Field Type Required Remarks     Source string ✅ Yes    Name string ❌ No    UniqueName string ❌ No    ShortName string ❌ No    ElementType string ❓ Depends Usually automatically detected by the AssemblyReader step. If correct, no need to specify it.   InputType string ❌ No    ModelType string ❌ No    ConvertInputToModel string ❌ No    ConvertModelToValue string ❌ No    UpdateCode string ❌ No     Dummy property # { \u0026quot;source\u0026quot;: null, \u0026quot;name\u0026quot;: \u0026quot;Name\u0026quot;, \u0026quot;inputType\u0026quot;: \u0026quot;InputType\u0026quot; }     Field Type Required Remarks     Source string ❌ No Must be null or not declared   Name string ✅ Yes    UniqueName string ❌ No    ShortName string ❌ No    ElementType string ❓ Depends Must be declared if property is a collection   InputType string ✅ Yes    ModelType string ❌ No    ConvertInputToModel string ❌ No    ConvertModelToValue string ❌ No    UpdateCode string ❌ No     "}).add({id:35,href:"https://fsprojects.github.io/Fabulous/docs/v1/extensions/ffimageloading/",title:"FFImageLoading",description:"The FFImageLoading plugin allows you to cache images as opposed to wasting time and memory with the built-in Image view. Using FFImageLoading, you have an easy way to cache images in your Fabulous.XamarinForms application.\nFFImageLoading was created by Daniel Luberda and Fabien Molinet. The original project can be found in this github repository.\nThe nuget Fabulous.XamarinForms.FFImageLoading implements a view component for the type CachedImage.\n   Source: The FFImageLoading github project by Daniel Luberda and Fabien Molinet",content:"The FFImageLoading plugin allows you to cache images as opposed to wasting time and memory with the built-in Image view. Using FFImageLoading, you have an easy way to cache images in your Fabulous.XamarinForms application.\nFFImageLoading was created by Daniel Luberda and Fabien Molinet. The original project can be found in this github repository.\nThe nuget Fabulous.XamarinForms.FFImageLoading implements a view component for the type CachedImage.\n   Source: The FFImageLoading github project by Daniel Luberda and Fabien Molinet\nInstallation # To use Fabulous.XamarinForms.FFImageLoading, you must:\n  Add a reference to this NuGet package across your whole solution. This will add appropriate references to your platform-specific Android, iOS, UWP, WPF etc projects too.\n  Add this line to your platform specific projects (AppDelegate.fs, MainActivity.fs, MainPage.xaml.cs, etc) before you use FFImageLoading:\n   If you’re using Android:  FFImageLoading.Forms.Platform.CachedImageRenderer.Init(enableFastRenderer = Nullable [true]/[false])   If you’re using non-Android platforms:  FFImageLoading.Forms.Platform.CachedImageRenderer.Init()   Use CachedImage in your view function. Here is a simple example of using CachedImage to display a scenic image:  View.CachedImage( source = ImagePath \u0026quot;http://loremflickr.com/600/600/nature?filename=simple.jpg\u0026quot;, height = 600., width = 600. )  Performance considerations # Use FileImageSource, UriImageSource or FFImageLoading\u0026rsquo;s EmbeddedResourceImageSource instead of StreamImageSource or ImageSource.FromResource to ensure the images are cached properly. Read more here on the FFImageLoading wiki\nSee also:\n Interface Objects The FFImageLoading wiki Source for the FFImageLoading extension Source of FFImageLoading Defining Extensions  "}).add({id:36,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/flyoutpage/",title:"FlyoutPage",description:"Basic example # View.FlyoutPage( flyout = View.ContentPage( title =\u0026quot;flyoutPage\u0026quot;, content = View.StackLayout([ View.ListViewGrouped( items = [ \u0026quot;Introduction Pages\u0026quot;, View.TextCell(\u0026quot;Introduction Pages\u0026quot;), introductionPages \u0026quot;Sample Pages\u0026quot;, View.TextCell(\u0026quot;Sample Pages\u0026quot;), samplePages \u0026quot;Sample Layouts\u0026quot;, View.TextCell(\u0026quot;Sample Layouts\u0026quot;), sampleLayouts \u0026quot;Sample Displays\u0026quot;, View.TextCell(\u0026quot;Sample Displays\u0026quot;), sampleDisplays ], itemSelected = (fun idx -\u0026gt; dispatch (ListViewSelectedItemChanged idx.Value)) ) ]) ), detail = View.NavigationPage( title = \u0026quot;details\u0026quot;, pages = [ activePage model.SelectedPage ] ) )  See also:\n Xamarin.Forms.FlyoutPage  ",content:"Basic example # View.FlyoutPage( flyout = View.ContentPage( title =\u0026quot;flyoutPage\u0026quot;, content = View.StackLayout([ View.ListViewGrouped( items = [ \u0026quot;Introduction Pages\u0026quot;, View.TextCell(\u0026quot;Introduction Pages\u0026quot;), introductionPages \u0026quot;Sample Pages\u0026quot;, View.TextCell(\u0026quot;Sample Pages\u0026quot;), samplePages \u0026quot;Sample Layouts\u0026quot;, View.TextCell(\u0026quot;Sample Layouts\u0026quot;), sampleLayouts \u0026quot;Sample Displays\u0026quot;, View.TextCell(\u0026quot;Sample Displays\u0026quot;), sampleDisplays ], itemSelected = (fun idx -\u0026gt; dispatch (ListViewSelectedItemChanged idx.Value)) ) ]) ), detail = View.NavigationPage( title = \u0026quot;details\u0026quot;, pages = [ activePage model.SelectedPage ] ) )  See also:\n Xamarin.Forms.FlyoutPage  "}).add({id:37,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/gestures/",title:"Gestures",description:"Gesture recognizers can be added to any visual element.\nTap Gestures # The tap gesture is used for tap detection. For example, here is a TapGestureRecognizer:\nView.Frame( hasShadow = true, gestureRecognizers = [ View.TapGestureRecognizer(command=(fun () -\u0026gt; dispatch FrameTapped)) ] )  See also:\n Adding a Tap Gesture Gesture Recognizer Xamarin.Forms.Core.TapGestureRecognizer  Pan Gestures # The pan gesture is used for detecting dragging. A common scenario for the pan gesture is to horizontally and vertically drag an image, so that all of the image content can be viewed when it\u0026rsquo;s being displayed in a viewport smaller than the image dimensions.",content:"Gesture recognizers can be added to any visual element.\nTap Gestures # The tap gesture is used for tap detection. For example, here is a TapGestureRecognizer:\nView.Frame( hasShadow = true, gestureRecognizers = [ View.TapGestureRecognizer(command=(fun () -\u0026gt; dispatch FrameTapped)) ] )  See also:\n Adding a Tap Gesture Gesture Recognizer Xamarin.Forms.Core.TapGestureRecognizer  Pan Gestures # The pan gesture is used for detecting dragging. A common scenario for the pan gesture is to horizontally and vertically drag an image, so that all of the image content can be viewed when it\u0026rsquo;s being displayed in a viewport smaller than the image dimensions. This is accomplished by moving the image within the viewport, and is demonstrated in this article.\nHere is an example of a PanGestureRecognizer used to recognize panning touch movements:\nView.Frame( hasShadow = true, gestureRecognizers = [ View.PanGestureRecognizer(touchPoints=1, panUpdated=(fun panArgs -\u0026gt; if panArgs.StatusType = GestureStatus.Running then dispatch (PanGesture panArgs))) ] )  See also:\n Adding a Pan Gesture Gesture Recognizer Xamarin.Forms.Core.PanGestureRecognizer  Pinch Gestures # The pinch gesture is used for performing interactive zoom. A common scenario for the pinch gesture is to perform interactive zoom of an image at the pinch location. This is accomplished by scaling the content of the viewport, and is demonstrated in this article.\nHere is an example of a PinchGestureRecognizer used to recognize pinch-or-expand touch movements:\nView.Frame( hasShadow=true, gestureRecognizers= [ View.PinchGestureRecognizer(pinchUpdated=(fun pinchArgs -\u0026gt; dispatch (UpdateSize (pinchArgs.Scale, pinchArgs.Status)))) ] )  See also:\n Adding a Pinch Gesture Gesture Recognizer Xamarin.Forms.Core.PinchGestureRecognizer  "}).add({id:38,href:"https://fsprojects.github.io/Fabulous/docs/v1/tutorials/how-to/",title:"How to write your own extensions",description:"Many open source and 3rd-party libraries of Xamarin.Forms controls exist. To use other controls, a small amount of wrapper code is typically needed to define a corresponding view element using the incremental-update model used by Fabulous.\nThe following additional view elements are available as pre-built nuget libraries:\n FFImageLoading for cached images, as opposed to the built-in Image view that wastes time and memory Maps for platform maps SkiaSharp for drawing 2D graphics OxyPlot for charting VideoManager for playing audio and video  To use other Xamarin.",content:"Many open source and 3rd-party libraries of Xamarin.Forms controls exist. To use other controls, a small amount of wrapper code is typically needed to define a corresponding view element using the incremental-update model used by Fabulous.\nThe following additional view elements are available as pre-built nuget libraries:\n FFImageLoading for cached images, as opposed to the built-in Image view that wastes time and memory Maps for platform maps SkiaSharp for drawing 2D graphics OxyPlot for charting VideoManager for playing audio and video  To use other Xamarin.Forms controls, a small amount of wrapper code must be written to convert the control to an Fabulous view element.\n Please consider contributing your extensions to this repository.\n The basic shape of an extension view component is shown below. Here we assume the Xamarin.Forms control defines one extra element called ABC deriving from existing element kind BASE, and that ABC has one additional collection property Prop1 and one primitive property Prop2. (A collection property is a one that may contain further sub-elements, e.g. children for StackLayout, gestureRecognizers for any View and pins in the Maps example further below.)\nAn view element simply defines a static member that extends View and returns a ViewElement. The view element inherits attributes and update functionality from BASE via prototype inheritance.\n NOTE: we are considering adding a code generator or type provider to automate this process, though the code is not complex to write.\nNOTE: The API used to write these extensions is subject to change.\n [\u0026lt;AutoOpen\u0026gt;] module MyViewExtensions = open Fabulous open Fabulous.XamarinForms // Define keys for the possible attributes let Prop1AttribKey = AttributeKey\u0026lt;seq\u0026lt;ViewElement\u0026gt;\u0026gt; \u0026quot;ABC_Prop1\u0026quot; let Prop2AttribKey = AttributeKey\u0026lt;bool\u0026gt; \u0026quot;ABC_Prop2\u0026quot; // Fully-qualified name to avoid extending by mistake // another View class (like Xamarin.Forms.View) type Fabulous.XamarinForms.View with /// Describes a ABC in the view /// The inline keyword is important for performance static member inline ABC(?prop1: seq\u0026lt;ViewElement\u0026gt;, ?prop2: bool, ... inherited attributes ... ) = // Count the number of additional attributes let attribCount = 0 let attribCount = match prop1 with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match prop2 with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount // Unbox the ViewRef let viewRef = match ref with None -\u0026gt; None | Some (ref: ViewRef\u0026lt;ABC\u0026gt;) -\u0026gt; Some ref.Unbox // Populate the attributes of the base element let attribs = ViewBuilders.BuildBASE(attribCount, ... inherited attributes (with ?ref=viewRef) ... ) // Add our own attributes. match prop1 with None -\u0026gt; () | Some v -\u0026gt; attribs.Add (Prop1AttribKey, v) match prop2 with None -\u0026gt; () | Some v -\u0026gt; attribs.Add (Prop2AttribKey, v) ... // The creation method let create () = new ABC() // The incremental update method let update (prev: ViewElement voption) (source: ViewElement) (target: ABC) = ViewBuilders.UpdateBASE (prev, source, target) source.UpdateElementCollection (prev, rop1AttribKey, target.Prop1) source.UpdatePrimitive (prev, target, Prop2AttribKey, (fun target -\u0026gt; target.Prop2), (fun target v -\u0026gt; target.Prop2 \u0026lt;- v)) ... ViewElement.Create\u0026lt;ABC\u0026gt;(create, update, attribs)  The control is then used as follows:\nView.ABC(Prop1 = [ View.Label(\u0026quot;hello\u0026quot;) ], prop2 = true, property3 = \u0026quot;Yo!\u0026quot;)  The update method of the extension is specified using:\n source.UpdatePrimitive(prev, target, attribKey, setter, ?defaultValue) - incrementally update a primitive source.UpdateElement(prev, target, attribKey, getter, setter) - incrementally update a nested element source.UpdateElementCollection(prev, attribKey, targetCollection) - incrementally update a collection of nested elements source.UpdateEvent(prev, target, attribKey, setter, ?defaultValue) - incrementally update a primitive event  Sometimes it makes sense to \u0026ldquo;massage\u0026rdquo; the input values before storing them in attibutes, e.g. to apply a conversion from an F#-friendly value to a stored attribte value here:\nmatch prop1 with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(Prop1AttribKey, box (CONV v))  It is common to mark view extensions as inline. This allows the F# compiler to create more optimized element-creation code for each particular instantiation based on the small set of properties specified at a particular usage point. In particular the compiler can statically determine the count of attributes and remove all allocations related to optional arguments.\nExample: Authoring the Xamarin.Forms.Maps Extension # The implementation of an extension for Xamarin.Forms.Maps is shown below - this is the same extension as that available in Fabulous.XamarinForms.Maps.dll. The sample implements the extension for the types Map and Pin.\n[\u0026lt;AutoOpen\u0026gt;] module MapsExtension = open Fabulous.XamarinForms open Xamarin.Forms open Xamarin.Forms.Maps let MapHasScrollEnabledAttribKey = AttributeKey \u0026quot;Map_HasScrollEnabled\u0026quot; let MapIsShowingUserAttribKey = AttributeKey \u0026quot;Map_IsShowingUser\u0026quot; let MapPinsAttribKey = AttributeKey \u0026quot;Map_Pins\u0026quot; let MapTypeAttribKey = AttributeKey \u0026quot;Map_MapType\u0026quot; let MapHasZoomEnabledAttribKey = AttributeKey \u0026quot;Map_HasZoomEnabled\u0026quot; let MapRequestingRegionAttribKey = AttributeKey \u0026quot;Map_RequestedRegion\u0026quot; let PinPositionAttribKey = AttributeKey \u0026quot;Pin_Position\u0026quot; let PinLabelAttribKey = AttributeKey \u0026quot;Pin_Label\u0026quot; let PinTypeAttribKey = AttributeKey \u0026quot;Pin_PinType\u0026quot; let PinAddressAttribKey = AttributeKey \u0026quot;Pin_Address\u0026quot; type Fabulous.XamarinForms.View with /// Describes a Map in the view static member inline Map(?pins: seq\u0026lt;ViewElement\u0026gt;, ?isShowingUser: bool, ?mapType: MapType, ?hasScrollEnabled: bool, ?hasZoomEnabled: bool, ?requestedRegion: MapSpan, // inherited attributes common to all views ?horizontalOptions, ?verticalOptions, ?margin, ?gestureRecognizers, ?anchorX, ?anchorY, ?backgroundColor, ?heightRequest, ?inputTransparent, ?isEnabled, ?isVisible, ?minimumHeightRequest, ?minimumWidthRequest, ?opacity, ?rotation, ?rotationX, ?rotationY, ?scale, ?style, ?translationX, ?translationY, ?widthRequest, ?resources, ?styles, ?styleSheets, ?classId, ?styleId, ?automationId) = // Count the number of additional attributes let attribCount = 0 let attribCount = match pins with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match hasScrollEnabled with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match isShowingUser with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match mapType with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match hasZoomEnabled with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match requestedRegion with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount // Count and populate the inherited attributes let attribs = ViewBuilders.BuildView(attribCount, ?horizontalOptions=horizontalOptions, ?verticalOptions=verticalOptions, ?margin=margin, ?gestureRecognizers=gestureRecognizers, ?anchorX=anchorX, ?anchorY=anchorY, ?backgroundColor=backgroundColor, ?heightRequest=heightRequest, ?inputTransparent=inputTransparent, ?isEnabled=isEnabled, ?isVisible=isVisible, ?minimumHeightRequest=minimumHeightRequest, ?minimumWidthRequest=minimumWidthRequest, ?opacity=opacity, ?rotation=rotation, ?rotationX=rotationX, ?rotationY=rotationY, ?scale=scale, ?style=style, ?translationX=translationX, ?translationY=translationY, ?widthRequest=widthRequest, ?resources=resources, ?styles=styles, ?styleSheets=styleSheets, ?classId=classId, ?styleId=styleId, ?automationId=automationId) // Add our own attributes. They must have unique names which must match the names below. match pins with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(MapPinsAttribKey, v) match hasScrollEnabled with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(MapHasScrollEnabledAttribKey, v) match isShowingUser with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(MapIsShowingUserAttribKey, v) match mapType with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(MapTypeAttribKey, v) match hasZoomEnabled with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(MapHasZoomEnabledAttribKey, v) match requestedRegion with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(MapRequestingRegionAttribKey, v) // The update method let update (prevOpt: ViewElement voption) (source: ViewElement) (target: Map) = ViewBuilders.UpdateView(prevOpt, source, target) source.UpdatePrimitive(prevOpt, target, MapHasScrollEnabledAttribKey, (fun target v -\u0026gt; target.HasScrollEnabled \u0026lt;- v)) source.UpdatePrimitive(prevOpt, target, MapHasZoomEnabledAttribKey, (fun target v -\u0026gt; target.HasZoomEnabled \u0026lt;- v)) source.UpdatePrimitive(prevOpt, target, MapIsShowingUserAttribKey, (fun target v -\u0026gt; target.IsShowingUser \u0026lt;- v)) source.UpdatePrimitive(prevOpt, target, MapTypeAttribKey, (fun target v -\u0026gt; target.MapType \u0026lt;- v)) source.UpdateElementCollection(prevOpt, MapPinsAttribKey, target.Pins) source.UpdatePrimitive(prevOpt, target, MapRequestingRegionAttribKey, (fun target v -\u0026gt; target.MoveToRegion(v))) // The element ViewElement.Create\u0026lt;Xamarin.Forms.Maps.Map\u0026gt;(Map, update, attribs) /// Describes a Pin in the view static member Pin(?position: Position, ?label: string, ?pinType: PinType, ?address: string) = // Count the number of additional attributes let attribCount = 0 let attribCount = match position with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match label with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match pinType with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribCount = match address with Some _ -\u0026gt; attribCount + 1 | None -\u0026gt; attribCount let attribs = AttributesBuilder(attribCount) // Add our own attributes. They must have unique names which must match the names below. match position with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(PinPositionAttribKey, v) match label with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(PinLabelAttribKey, v) match pinType with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(PinTypeAttribKey, v) match address with None -\u0026gt; () | Some v -\u0026gt; attribs.Add(PinAddressAttribKey, v) // The update method let update (prevOpt: ViewElement voption) (source: ViewElement) (target: Pin) = source.UpdatePrimitive(prevOpt, target, PinPositionAttribKey, (fun target v -\u0026gt; target.Position \u0026lt;- v)) source.UpdatePrimitive(prevOpt, target, PinLabelAttribKey, (fun target v -\u0026gt; target.Label \u0026lt;- v)) source.UpdatePrimitive(prevOpt, target, PinTypeAttribKey, (fun target v -\u0026gt; target.Type \u0026lt;- v)) source.UpdatePrimitive(prevOpt, target, PinAddressAttribKey, (fun target v -\u0026gt; target.Address \u0026lt;- v)) // The element ViewElement.Create\u0026lt;Xamarin.Forms.Maps.Pin\u0026gt;(Pin, update, attribs)  In the above example, inherited properties from View (such as margin or horizontalOptions) have been included in the facade for Map. These properties need not be added, you can set them on elements using the helper With, usable for all View properties:\nView.Map(hasZoomEnabled = true, hasScrollEnabled = true).With(horizontalOptions = LayoutOptions.FillAndExpand)  Example: MasterDetailPage without a toolbar on UWP with custom ViewBuilders # Fabulous uses ViewBuilders to create the underlying Xamarin.Forms classes. Customizing ViewBuilders is not the recommended way for custom controls but it is a great solution for overridden controls like in the following example:\ntype MasterDetailPageWithoutToolbar() = inherit Xamarin.Forms.MasterDetailPage() override __.ShouldShowToolbarButton() = false Fabulous.XamarinForms.ViewBuilders.CreateFuncMasterDetailPage \u0026lt;- fun () -\u0026gt; upcast(new MasterDetailPageWithoutToolbar()) View.MasterDetailPage() // this now uses MasterDetailPageWithoutToolbar  See also:\n Core Elements Maps SkiaSharp Source for the Maps extension Source for the SkiaSharp extension  "}).add({id:39,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/image/",title:"Image",description:"Basic example # View.Image(Image.ImagePath \u0026quot;icon.png\u0026quot;)  Basic example with styling # View.Image( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, source = Image.ImagePath \u0026quot;icon.png\u0026quot; )  See also:\n Image in Xamarin Forms Xamarin.Forms.Image  More examples # A simple image drawn from a resource or URL is as follows:\nlet monkey = \u0026quot;http://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/Papio_anubis_%28Serengeti%2C_2009%29.jpg/200px-Papio_anubis_%28Serengeti%2C_2009%29.jpg\u0026quot; View.Image(Image.ImagePath monkey)  ",content:"Basic example # View.Image(Image.ImagePath \u0026quot;icon.png\u0026quot;)  Basic example with styling # View.Image( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, source = Image.ImagePath \u0026quot;icon.png\u0026quot; )  See also:\n Image in Xamarin Forms Xamarin.Forms.Image  More examples # A simple image drawn from a resource or URL is as follows:\nlet monkey = \u0026quot;http://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/Papio_anubis_%28Serengeti%2C_2009%29.jpg/200px-Papio_anubis_%28Serengeti%2C_2009%29.jpg\u0026quot; View.Image(Image.ImagePath monkey)  "}).add({id:40,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/imagebutton/",title:"ImageButton",description:"Basic example # View.ImageButton(Image.ImagePath \u0026quot;icon.png\u0026quot;)  Basic example with styling # View.ImageButton( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ButtonColor, padding = style.Padding, source = Image.ImagePath \u0026quot;icon.png\u0026quot; )  See also:\n ImageButton in Xamarin Forms Xamarin.Forms.ImageButton  More examples # The ImageButton displays an image and responds to a tap or click that directs an application to carry out a particular task.\nlet monkey = \u0026quot;http://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/Papio_anubis_%28Serengeti%2C_2009%29.jpg/200px-Papio_anubis_%28Serengeti%2C_2009%29.jpg\u0026quot; View.ImageButton(Image.ImagePath monkey)  ",content:"Basic example # View.ImageButton(Image.ImagePath \u0026quot;icon.png\u0026quot;)  Basic example with styling # View.ImageButton( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ButtonColor, padding = style.Padding, source = Image.ImagePath \u0026quot;icon.png\u0026quot; )  See also:\n ImageButton in Xamarin Forms Xamarin.Forms.ImageButton  More examples # The ImageButton displays an image and responds to a tap or click that directs an application to carry out a particular task.\nlet monkey = \u0026quot;http://upload.wikimedia.org/wikipedia/commons/thumb/f/fc/Papio_anubis_%28Serengeti%2C_2009%29.jpg/200px-Papio_anubis_%28Serengeti%2C_2009%29.jpg\u0026quot; View.ImageButton(Image.ImagePath monkey)  "}).add({id:41,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/indicatorview/",title:"IndicatorView",description:"Basic example # View.StackLayout([ View.IndicatorView( ref = indicatorRef, indicatorColor = Color.Red, selectedIndicatorColor = Color.Blue, indicatorsShape = IndicatorShape.Square ) View.CarouselView( indicatorView = indicatorRef, items = [ View.Label(\u0026quot;First CarouselView with IndicatorView\u0026quot;) View.Label(\u0026quot;Second CarouselView with IndicatorView\u0026quot;) View.Label(\u0026quot;Third CarouselView with IndicatorView\u0026quot;) ] ) ])  Basic example with styling # View.StackLayout([ View.IndicatorView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, padding = style.Padding, ref = indicatorRef, indicatorColor = Color.Red, selectedIndicatorColor = Color.Blue, indicatorsShape = IndicatorShape.",content:"Basic example # View.StackLayout([ View.IndicatorView( ref = indicatorRef, indicatorColor = Color.Red, selectedIndicatorColor = Color.Blue, indicatorsShape = IndicatorShape.Square ) View.CarouselView( indicatorView = indicatorRef, items = [ View.Label(\u0026quot;First CarouselView with IndicatorView\u0026quot;) View.Label(\u0026quot;Second CarouselView with IndicatorView\u0026quot;) View.Label(\u0026quot;Third CarouselView with IndicatorView\u0026quot;) ] ) ])  Basic example with styling # View.StackLayout([ View.IndicatorView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, padding = style.Padding, ref = indicatorRef, indicatorColor = Color.Red, selectedIndicatorColor = Color.Blue, indicatorsShape = IndicatorShape.Square ) View.CarouselView( indicatorView = indicatorRef, items = [ View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;First CarouselView with IndicatorView\u0026quot; ) View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor2, padding = style.Padding, text = \u0026quot;Second CarouselView with IndicatorView\u0026quot; ) View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor3, padding = style.Padding, text = \u0026quot;Third CarouselView with IndicatorView\u0026quot; ) ] ) ])  See also:\n IndicatorView in Xamarin Forms Xamarin.Forms.IndicatorView  "}).add({id:42,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/label/",title:"Label",description:"Basic example # View.Label(\u0026quot;Label\u0026quot;)  Basic example with styling # View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;Label\u0026quot; )  See also:\n Label in Xamarin Forms Xamarin.Forms.Label  More examples # The Label view is used for displaying text, both single and multi-line. Labels can have text decorations, colored text, and use custom fonts (families, sizes, and options).\nView.Label(text = \u0026quot;this is a label\u0026quot;)  ",content:"Basic example # View.Label(\u0026quot;Label\u0026quot;)  Basic example with styling # View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;Label\u0026quot; )  See also:\n Label in Xamarin Forms Xamarin.Forms.Label  More examples # The Label view is used for displaying text, both single and multi-line. Labels can have text decorations, colored text, and use custom fonts (families, sizes, and options).\nView.Label(text = \u0026quot;this is a label\u0026quot;)  "}).add({id:43,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/layouts/",title:"Layouts",description:"Xamarin.Forms has several layouts and features for organizing content on screen. For a comprehensive guide see the Xamarin Guide to Layouts\nLayouts with single content #    Layout Description Appearance     ContentView contains a single child    Frame displays a border, or frame, around its single child    ScrollView capable of scrolling its contents     Layouts with multiple children #    Layout Description Appearance     StackLayout positions child elements in a stack either horizontally or vertically    Grid positions its child elements in a grid of rows and columns    AbsoluteLayout positions child elements at specific locations relative to its parent    RelativeLayout positions child elements relative to the RelativeLayout itself or to their siblings    FlexLayout allows children to be stacked or wrapped with many alignment and orientation options.",content:"Xamarin.Forms has several layouts and features for organizing content on screen. For a comprehensive guide see the Xamarin Guide to Layouts\nLayouts with single content #    Layout Description Appearance     ContentView contains a single child    Frame displays a border, or frame, around its single child    ScrollView capable of scrolling its contents     Layouts with multiple children #    Layout Description Appearance     StackLayout positions child elements in a stack either horizontally or vertically    Grid positions its child elements in a grid of rows and columns    AbsoluteLayout positions child elements at specific locations relative to its parent    RelativeLayout positions child elements relative to the RelativeLayout itself or to their siblings    FlexLayout allows children to be stacked or wrapped with many alignment and orientation options.      Xamarin.Forms Layouts \nContent View # A ContentView contains a single child element and is typically used to create custom, reusable controls.\nView.ContentView( View.Label(\u0026quot;content\u0026quot;) )  See also:\n Xamarin guide to ContentView Xamarin API docs for ContentView  Frame # A frame contains other content. A simple Frame is as follows:\nView.Frame( hasShadow = true, backgroundColor = Color.Fuchsia, content = View.Label(\u0026quot;I'm framed\u0026quot;) )  See also:\n Xamarin.Forms.Core.Frame  ScrollView # ScrollView contains layouts and enables them to scroll offscreen. ScrollView is also used to allow views to automatically move to the visible portion of the screen when the keyboard is showing.\nView.ScrollView( View.StackLayout([ for i in 1 .. 100 -\u0026gt; View.Label(text = sprintf \u0026quot;item %i\u0026quot; i) ]) )  The scroll position can be setted programmatically through the attribute scrollTo. This attribute needs the X and Y coordinates to scroll to and an indication whether it should be animated or not. (Animated/NotAnimated)\nNote: Fabulous will try to scroll to these coordinates every time it needs to refresh the UI. Making use of the optional argument is recommended.\nYou can also subscribe to the event Scrolled to be notified when the scrolling is over.\nFor more complex scenarios, you can directly use the method from Xamarin.Forms ScrollView.ScrollToAsync(x, y, animated) This method offers the advantage of being awaitable until the end of the scrolling. To do this, a reference to the underlying ScrollView is needed.\nlet scrollViewRef = ViewRef\u0026lt;ScrollView\u0026gt;() View.ScrollView(ref=scrollViewRef, content=(...)) // Some time later (usually in a Cmd) let scrollToCoordinates x y animated = async { match scrollViewRef.TryValue with | None -\u0026gt; return None | Some scrollView -\u0026gt; do! scrollView.ScrollToAsync(x, y, animated) |\u0026gt; Async.AwaitTask return (Some Scrolled) } |\u0026gt; Cmd.ofAsyncMsgOption  See also:\n Xamarin guide to ScrollView Xamarin.Forms.Core.ScrollView  StackLayout # StackLayout organizes views in a one-dimensional line (\u0026ldquo;stack\u0026rdquo;), either horizontally or vertically. Views in a StackLayout can be sized based on the space in the layout using layout options. Positioning is determined by the order views were added to the layout and the layout options of the views.\nView.StackLayout(children = [ View.Label(\u0026quot;first label\u0026quot;) View.Button(text = \u0026quot;first button\u0026quot;) View.Label(\u0026quot;second label\u0026quot;) ])  See also:\n Xamarin guide to StackLayout Xamarin API docs for StackLayout  Grid # Grid supports arranging views into rows and columns. Rows and columns can be set to have proportional sizes or absolute sizes. The Grid layout should not be confused with traditional tables and is not intended to present tabular data. Grid does not have the concept of row, column or cell formatting. Unlike HTML tables, Grid is purely intended for laying out content.\nAn example Grid is as follows:\nView.Grid( rowdefs = [ Dimension.Auto // first row = .Row(0) Dimension.Absolute 150. // second row = .Row(1) Dimension.Auto // third row = .Row(2) Dimension.Star // fourth row = .Row(3) ], coldefs = [ Dimension.Absolute 200. // first column = .Column(0) Dimension.Star // second column = .Column(1) ], children = [ View.Label(text = \u0026quot;first row\u0026quot;, backgroundColor = Color.Red).Row(0) View.Label(text = \u0026quot;second row\u0026quot;, backgroundColor = Color.Blue).Row(1) View.Label(text = \u0026quot;first column\u0026quot;, backgroundColor = Color.Yellow).Row(2).Column(0) View.Label(text = \u0026quot;second column\u0026quot;, backgroundColor = Color.Green).Row(2).Column(1) View.Label(text = \u0026quot;column spanning\u0026quot;, backgroundColor = Color.Orange).Row(3).ColumnSpan(2) ] )  See also:\n Xamarin.Forms.Core.Grid  AbsoluteLayout # AbsoluteLayout positions and sizes child elements proportional to its own size and position or by absolute values. Child views may be positioned and sized using proportional values or static values, and proportional and static values can be mixed.\nView.AbsoluteLayout( backgroundColor = Color.Blue.WithLuminosity(0.9), children = [ View.Label(text = \u0026quot;Top Left\u0026quot;, textColor = Color.Black) .LayoutFlags(AbsoluteLayoutFlags.PositionProportional) .LayoutBounds(Rectangle(0.0, 0.0, AbsoluteLayout.AutoSize, AbsoluteLayout.AutoSize)) View.Label(text = \u0026quot;Centered\u0026quot;, textColor = Color.Black) .LayoutFlags(AbsoluteLayoutFlags.PositionProportional) .LayoutBounds(Rectangle(0.5, 0.5, AbsoluteLayout.AutoSize, AbsoluteLayout.AutoSize)) View.Label(text = \u0026quot;Bottom Right\u0026quot;, textColor = Color.Black) .LayoutFlags(AbsoluteLayoutFlags.PositionProportional) .LayoutBounds(Rectangle(1.0, 1.0, AbsoluteLayout.AutoSize, AbsoluteLayout.AutoSize)) ] )  See also:\n Xamarin guide to AbsoluteLayout Xamarin API docs for AbsoluteLayout  RelativeLayout # RelativeLayout is used to position and size views relative to properties of the layout or sibling views. Unlike AbsoluteLayout, RelativeLayout does not have the concept of the moving anchor and does not have facilities for positioning elements relative to the bottom or right edges of the layout. RelativeLayout does support positioning elements outside of its own bounds.\nAn example RelativeLayout is as follows:\nView.RelativeLayout([ View.Label(text = \u0026quot;RelativeLayout Example\u0026quot;, textColor = Color.Red) .XConstraint(Constraint.RelativeToParent(fun parent -\u0026gt; 0.0)) View.Label(text = \u0026quot;Positioned relative to my parent\u0026quot;, textColor = Color.Red) .XConstraint(Constraint.RelativeToParent(fun parent -\u0026gt; parent.Width / 3.0)) .YConstraint(Constraint.RelativeToParent(fun parent -\u0026gt; parent.Height / 2.0)) ])  See also:\n Xamarin guide to RelativeLayout Xamarin API docs for RelativeLayout  FlexLayout # FlexLayout is similar to the Xamarin.Forms StackLayout in that it can arrange its children horizontally and vertically in a stack. However, the FlexLayout is also capable of wrapping its children if there are too many to fit in a single row or column, and also has many options for orientation, alignment, and adapting to various screen sizes.\nView.FlexLayout( direction = FlexDirection.Column, children = [ View.Label(text = \u0026quot;Seated Monkey\u0026quot;, fontSize = FontSize.fromNamedSize NamedSize.Large, textColor=Color.Blue) View.Label(text = \u0026quot;This monkey is laid back and relaxed.\u0026quot;) View.Label(text = \u0026quot; - Often smiles mysteriously\u0026quot;) View.Label(text = \u0026quot; - Sleeps sitting up\u0026quot;) View.Image( source = Image.ImagePath \u0026quot;images/160px-Vervet_monkey_Krugersdorp_game_reserve_%285657678441%29.jpg\u0026quot; ).Order(-1).AlignSelf(FlexAlignSelf.Center) View.Label(margin = Thickness(0.0, 4.0)).Grow(1.0) View.Button(text = \u0026quot;Learn More\u0026quot;, fontSize = FontSize.fromNamedSize NamedSize.Large, cornerRadius = 20) ] )  See also:\n Xamarin guide to FlexLayout Xamarin API docs for FlexLayout  "}).add({id:44,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/line/",title:"Line",description:"Basic example # View.Line( stroke = View.SolidColorBrush(Color.Black), x1 = 40., y1 = 0., x2 = 0., y2 = 120. )  Basic example with styling # View.Line( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, stroke = View.SolidColorBrush(Color.Black), x1 = 40., y1 = 0., x2 = 0., y2 = 120. )  See also:\n Line in Xamarin Forms Xamarin.Forms.Line  More examples # Line can be used to draw lines.",content:"Basic example # View.Line( stroke = View.SolidColorBrush(Color.Black), x1 = 40., y1 = 0., x2 = 0., y2 = 120. )  Basic example with styling # View.Line( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, stroke = View.SolidColorBrush(Color.Black), x1 = 40., y1 = 0., x2 = 0., y2 = 120. )  See also:\n Line in Xamarin Forms Xamarin.Forms.Line  More examples # Line can be used to draw lines.\n// Line View.Line( x1 = 40., y1 = 0., x2 = 0., y2 = 120., stroke = View.SolidColorBrush(Color.Red) ) // Line with stroke View.Line( x1 = 40., y1 = 0., x2 = 0., y2 = 120., stroke = View.SolidColorBrush(Color.DarkBlue), strokeThickness = 4. ) // Dashed line View.Line( x1 = 40., y1 = 0., x2 = 0., y2 = 120., stroke = View.SolidColorBrush(Color.DarkBlue), strokeDashArray = [ 1.; 1. ], strokeDashOffset = 6. ) // LineCap: Flat View.Line( x1 = 0., y1 = 20., x2 = 300., y2 = 20., stroke = View.SolidColorBrush(Color.Red), strokeThickness = 12., strokeLineCap = Shapes.PenLineCap.Flat ) // LineCap: Square View.Line( x1 = 0., y1 = 20., x2 = 300., y2 = 20., stroke = View.SolidColorBrush(Color.Red), strokeThickness = 12., strokeLineCap = Shapes.PenLineCap.Square ) // LineCap: Round View.Line( x1 = 0., y1 = 20., x2 = 300., y2 = 20., stroke = View.SolidColorBrush(Color.Red), strokeThickness = 12., strokeLineCap = Shapes.PenLineCap.Round )  "}).add({id:45,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/listview/",title:"ListView and ListViewGrouped",description:"Basic example ListView # View.ListView( itemSelected = (fun idx -\u0026gt; dispatch (ListViewSelectedItemChanged idx)), items = [ View.TextCell(\u0026quot;First ListView\u0026quot;) View.TextCell(\u0026quot;Second ListView\u0026quot;) View.TextCell(\u0026quot;Third ListView\u0026quot;) ] )  The itemSelected callback uses integers indexes for keys to identify the elements.\nThere is also a ListViewGrouped for grouped items of data. This uses the same Xamarin control under the hood but in a different mode of use.\nBasic example ListViewGrouped # View.ListViewGrouped( itemSelected = (fun idx -\u0026gt; dispatch (ListViewSelectedItemChanged idx)), items = [ \u0026quot;Group 1\u0026quot;, View.",content:"Basic example ListView # View.ListView( itemSelected = (fun idx -\u0026gt; dispatch (ListViewSelectedItemChanged idx)), items = [ View.TextCell(\u0026quot;First ListView\u0026quot;) View.TextCell(\u0026quot;Second ListView\u0026quot;) View.TextCell(\u0026quot;Third ListView\u0026quot;) ] )  The itemSelected callback uses integers indexes for keys to identify the elements.\nThere is also a ListViewGrouped for grouped items of data. This uses the same Xamarin control under the hood but in a different mode of use.\nBasic example ListViewGrouped # View.ListViewGrouped( itemSelected = (fun idx -\u0026gt; dispatch (ListViewSelectedItemChanged idx)), items = [ \u0026quot;Group 1\u0026quot;, View.TextCell \u0026quot;Group 1\u0026quot;, [ View.TextCell(\u0026quot;First item\u0026quot;) View.TextCell(\u0026quot;Second item\u0026quot;) View.TextCell(\u0026quot;Third item\u0026quot;) ] \u0026quot;Group 2\u0026quot;, View.TextCell \u0026quot;Group 2\u0026quot;, [ View.TextCell(\u0026quot;Fourth item\u0026quot;) View.TextCell(\u0026quot;Fifth item\u0026quot;) View.TextCell(\u0026quot;Sixth item\u0026quot;) ] ] )  See also:\n ListView in Xamarin Forms Xamarin.Forms.ListView  More examples # \u0026ldquo;Infinite\u0026rdquo; or \u0026ldquo;unbounded\u0026rdquo; ListViews # \u0026ldquo;Infinite\u0026rdquo; (really \u0026ldquo;unbounded\u0026rdquo;) lists are created by using the itemAppearing event to prompt a message which nudges the underlying model in a direction that will then supply new items to the view.\nFor example, consider this pattern:\ntype Model = { ... LatestItemAvailable: int } type Message = ... | GetMoreItems of int let update msg model = match msg with | ... | GetMoreItems n -\u0026gt; { model with LatestItemAvailable = n } let view model dispatch = ... View.ListView( itemAppearing = (fun idx -\u0026gt; if idx \u0026gt;= max - 2 then dispatch (GetMoreItems (idx + 10) ) ), items = [ for i in 1 .. model.LatestItemAvailable do yield View.TextCell(\u0026quot;Item \u0026quot; + string i) ] ) ...  Note:\n The underlying data in the model is just an integer LatestItemAvailable (normally it would really be a list of actual entities drawn from a data source) On each update to the view we produce all the visual items from Item 1 onwards The itemAppearing event is called for each item, e.g. when item 10 appears When the event triggers we grow the underlying data model by 10 This will trigger an update of the view again, with more visual elements available (but not yet appearing)  Surprisingly even this naive technique is fairly efficient. There are numerous ways to make this more efficient (we aim to document more of these over time too). One simple one is to memoize each individual visual item using dependsOn:\nitems = [ for i in 1 .. model.LatestItemAvailable do yield dependsOn i (fun model i -\u0026gt; View.Label(\u0026quot;Item \u0026quot; + string i)) ]  With that, this simple list views scale to \u0026gt; 10,000 items on a modern phone, though your mileage may vary. There are many other techniques (e.g. save the latest collection of visual element descriptions in the model, or to use a ConditionalWeakTable to associate it with the latest model). We will document further techniques in due course.\nThere is also an itemDisappearing event for ListView that can be used to discard data from the underlying model and restrict the range of visual items that need to be generated.\n"}).add({id:46,href:"https://fsprojects.github.io/Fabulous/docs/v1/tutorials/model/",title:"Models",description:"The model is the core data from which the whole state of the app can be resurrected. The model is generally immutable but may also contain elements such as service connections. It is common for the desgin of the model to grow \u0026ldquo;organically\u0026rdquo; as you prototype your app.\nThe init function returns your initial model. The update function updates the model as messages are received.\nMessages and Validation # Validation is generally done on updates to the model storing error messages from validation logic in the model so they can be correctly and simply displayed to the user.",content:"The model is the core data from which the whole state of the app can be resurrected. The model is generally immutable but may also contain elements such as service connections. It is common for the desgin of the model to grow \u0026ldquo;organically\u0026rdquo; as you prototype your app.\nThe init function returns your initial model. The update function updates the model as messages are received.\nMessages and Validation # Validation is generally done on updates to the model storing error messages from validation logic in the model so they can be correctly and simply displayed to the user. Here is a very basic example:\ntype Animal = | ValidAnimal of string | InvalidAnimal of string type Model = { AnimalName : Animal } type Msg = UpdateAnimal of string let validAnimalNames = [ \u0026quot;Emu\u0026quot;; \u0026quot;Kangaroo\u0026quot;; \u0026quot;Platypus\u0026quot;; \u0026quot;Wombat\u0026quot; ] let validateAnimal (animalName : string) = if List.contains animalName validAnimalNames then ValidAnimal animalName else InvalidAnimal animalName let update msg model = match msg with | UpdateAnimal animalName -\u0026gt; { model with AnimalName = validateAnimal animalName } let view (model: Model) dispatch : ViewElement = let makeEntryCell text = View.Entry( text = text, textChanged = fun textArgs -\u0026gt; UpdateAnimal textArgs.NewTextValue |\u0026gt; dispatch ) View.ContentPage( View.StackLayout( match model.AnimalName with | ValidAnimal validName -\u0026gt; [ makeEntryCell validName ] | InvalidAnimal invalidName -\u0026gt; [ makeEntryCell invalidName View.Label(sprintf \u0026quot;%s is not a valid animal name. Try %A\u0026quot; invalidName validAnimalNames) ] ) ) let init () = { AnimalName = validateAnimal \u0026quot;Emu\u0026quot; }  A more advanced validation might use the Result\u0026lt;'T,'TError\u0026gt; type to wrap parts of the model that require validation: in the previous example the Result type has somewhat been reinvented. Using Result provides a consistent way of knowing which parts of the model are in a valid state, use of the standard Result functions like map and bind to perform branching logic, and more comprehensive error messaging. One thing to note is that 'TError will usually need to carry the original input value so it can be displayed back to the user.\ntype Animal = Animal of string type ErrorMessage = | InvalidName of InputString : string | BlankName type Model = { AnimalName : Result\u0026lt;Animal,ErrorMessage\u0026gt; } type Msg = UpdateAnimal of string let validAnimalNames = [ \u0026quot;Emu\u0026quot;; \u0026quot;Kangaroo\u0026quot;; \u0026quot;Platypus\u0026quot;; \u0026quot;Wombat\u0026quot; ] let validateAnimal (animalName : string) = if animalName = \u0026quot;\u0026quot; then Error BlankName else if List.contains animalName validAnimalNames then Ok (Animal animalName) else Error (InvalidName animalName) let update msg model = match msg with | UpdateAnimal animalName -\u0026gt; { model with AnimalName = validateAnimal animalName } let view (model: Model) dispatch : ViewElement = let makeEntryCell text = View.Entry( text = text, textChanged = fun textArgs -\u0026gt; UpdateAnimal textArgs.NewTextValue |\u0026gt; dispatch ) let makeErrorMsg err = match err with | InvalidName invalidName -\u0026gt; [ makeEntryCell invalidName View.Label(text = sprintf \u0026quot;%s is not a valid animal name. Try %A\u0026quot; invalidName validAnimalNames) ] | BlankName -\u0026gt; [ makeEntryCell \u0026quot;\u0026quot; View.Label(text = sprintf \u0026quot;You must input a name\u0026quot;) ] View.ContentPage( View.StackLayout( match model.AnimalName with | Ok (Animal validName) -\u0026gt; [ makeEntryCell validName ] | Error errorMsg -\u0026gt; makeErrorMsg errorMsg ) ) let init () = { AnimalName = validateAnimal \u0026quot;Emu\u0026quot; }  Note that the same validation logic can be used in both your app and a service back-end.\nSaving Application State # Application state is very simple to save by serializing the model into app.Properties. For example, you can store as JSON as follows using Json.NET:\ntype Application() = .... let modelId = \u0026quot;model\u0026quot; override __.OnSleep() = let json = Newtonsoft.Json.JsonConvert.SerializeObject(runner.CurrentModel) Debug.WriteLine(\u0026quot;OnSleep: saving model into app.Properties, json = {0}\u0026quot;, json) app.Properties.[modelId] \u0026lt;- json override __.OnResume() = Debug.WriteLine \u0026quot;OnResume: checking for model in app.Properties\u0026quot; try match app.Properties.TryGetValue modelId with | true, (:? string as json) -\u0026gt; Debug.WriteLine(\u0026quot;OnResume: restoring model from app.Properties, json = {0}\u0026quot;, json) let model = Newtonsoft.Json.JsonConvert.DeserializeObject\u0026lt;App.Model\u0026gt;(json) Debug.WriteLine(\u0026quot;OnResume: restoring model from app.Properties, model = {0}\u0026quot;, (sprintf \u0026quot;%0A\u0026quot; model)) runner.SetCurrentModel (model, Cmd.none) | _ -\u0026gt; () with ex -\u0026gt; App.program.onError(\u0026quot;Error while restoring model found in app.Properties\u0026quot;, ex) override this.OnStart() = Debug.WriteLine \u0026quot;OnStart: using same logic as OnResume()\u0026quot; this.OnResume()  "}).add({id:47,href:"https://fsprojects.github.io/Fabulous/docs/v1/tutorials/mvu/",title:"MVU",description:"Applications built with Fabulous use the MVU design pattern (Model-View-Update, also known from the origin The Elm Architecture).\nHere is the typical structure for the main logic of an app:\ntype Msg = | ... /// The MODEL from which the view is generated type Model = { ... } /// Returns the initial state let init() = { ... } /// The funtion to UPDATE the view let update (msg:Msg) (model:Model) = .",content:"Applications built with Fabulous use the MVU design pattern (Model-View-Update, also known from the origin The Elm Architecture).\nHere is the typical structure for the main logic of an app:\ntype Msg = | ... /// The MODEL from which the view is generated type Model = { ... } /// Returns the initial state let init() = { ... } /// The funtion to UPDATE the view let update (msg:Msg) (model:Model) = ... /// The VIEW function giving updated content for the page let view (model: Model) dispatch = ... type App () as app = inherit Application () let runner = Program.mkSimple init update view |\u0026gt; Program.withConsoleTrace |\u0026gt; XamarinFormsProgram.run app  The model # The model is the core data from which the whole state of the app can be resurrected. When designing your model, ask yourself \u0026ldquo;what is the information I would need on restart to get the app back to the same essential state\u0026rdquo;. The model is generally immutable but may also contain elements such as service connections. It is common for the desgin of the model to grow \u0026ldquo;organically\u0026rdquo; as you prototype your app.\nSome advantages of using an immutable model are:\n It is easy to unit test your init, update and view functions You can save/restore your model relatively easily It makes tracing causality usually very simple  The init function returns your initial model. The update function updates the model as messages are received.\nThe view function # The view function computes an immutable Xaml-like description.\nThe update function # Each model gets an update function for message processing. The messages are either messages from the view or from external events. If using Program.mkProgram your update function may also return new commands to trigger as a result of processing a message. (A command is simply a function that may dispatch one or more messages at some point, and is called by the Fabulous runtime.)\nFurther Resources # Fabulous: Functional App Development\n"}).add({id:48,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/navigation/",title:"Navigation",description:"Multiple pages are generated as part of the overall view. Five multi-page navigation models are shown in the AllControls sample:\n NavigationPage using push/pop NavigationPage Toolbar TabbedPage CarouselPage MasterDetail  NavigationPage using push/pop # The basic principles of implementing push/pop navigation are as follows:\n Keep some information in your model indicating the page stack (e.g. a list of page identifiers or page models) Return the current visual page stack in the pages property of NavigationPage.",content:"Multiple pages are generated as part of the overall view. Five multi-page navigation models are shown in the AllControls sample:\n NavigationPage using push/pop NavigationPage Toolbar TabbedPage CarouselPage MasterDetail  NavigationPage using push/pop # The basic principles of implementing push/pop navigation are as follows:\n Keep some information in your model indicating the page stack (e.g. a list of page identifiers or page models) Return the current visual page stack in the pages property of NavigationPage. Set HasNavigationBar and HasBackButton on each sub-page according to your desire Dispatch messages in order to navigate, where the corresponding update adjusts the page stack in the model  let view model dispatch = View.NavigationPage(pages= [ for page in model.PageStack do match page with | \u0026quot;Home\u0026quot; -\u0026gt; yield View.ContentPage(...).HasNavigationBar(true).HasBackButton(true) | \u0026quot;PageA\u0026quot; -\u0026gt; yield View.ContentPage(...).HasNavigationBar(true).HasBackButton(true) | \u0026quot;PageB\u0026quot; -\u0026gt; yield View.ContentPage(...).HasNavigationBar(true).HasBackButton(true) ])  NavigationPage Toolbar # A toolbar can be added to a navigation page using .ToolbarItems([ ... ]) as follows:\nlet view model dispatch = ... View.NavigationPage(pages = [ View.ContentPage(...) .ToolbarItems([View.ToolbarItem(text = \u0026quot;About\u0026quot;, command = (fun () -\u0026gt; dispatch (ShowAbout true))) ] )  Example: Modal pages by pushing an extra page # A modal page can be achieved by yielding an additional page in the NavigationPage. For example, here is an \u0026ldquo;About\u0026rdquo; page example:\ntype Model = { ShowAbout: bool ... } type Msg = | ... | ShowAbout of bool let view model dispatch = ... let rootPage dispatch = View.ContentPage(title = \u0026quot;Root Page\u0026quot;, content = View.Button(text = \u0026quot;About\u0026quot;, command = (fun () -\u0026gt; dispatch (ShowAbout true)))) let modalPage dispatch = View.ContentPage(title = \u0026quot;About\u0026quot;, content= View.StackLayout( children = [ View.Label(text = \u0026quot;Fabulous!\u0026quot;) View.Button(text = \u0026quot;Continue\u0026quot;, command = (fun () -\u0026gt; dispatch (ShowAbout false) )) ])) View.NavigationPage(pages= [ yield rootPage dispatch if model.ShowAbout then yield modalPage dispatch ])  TabbedPage navigation # Return a TabbedPage from your view:\nlet view model dispatch = View.TabbedPage(children = [ ... ])  CarouselPage navigation # Return a CarouselPage from your view:\nlet view model dispatch = View.CarouselPage(children = [ ... ])  MasterDetail Page navigation # Return a FlyoutPage from your view:\nlet view model dispatch = View.FlyoutPage( flyout = View.ContentPage(title =\u0026quot;flyoutPage\u0026quot;, ...), // 'title' is needed for the flyout page detail = View.ContentPage(...) )  See also\n The AllControls sample  "}).add({id:49,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/navigationpage/",title:"NavigationPage",description:"Basic example # View.NavigationPage([ View.ContentPage( title = \u0026quot;ContentPage\u0026quot;, content = View.Label(\u0026quot;NavigationPage with a single Label\u0026quot;) ) ])  Basic example with styling # View.NavigationPage([ View.ContentPage( title = \u0026quot;ContentPage\u0026quot;, content = View.Label( horizontalOptions = model.MyStyle.Position, verticalOptions = model.MyStyle.Position, backgroundColor = model.MyStyle.ViewColor, padding = model.MyStyle.Padding, text = \u0026quot;NavigationPage with a single Label\u0026quot; ) ) ])  See also:\n Xamarin.Forms.NavigationPage  ",content:"Basic example # View.NavigationPage([ View.ContentPage( title = \u0026quot;ContentPage\u0026quot;, content = View.Label(\u0026quot;NavigationPage with a single Label\u0026quot;) ) ])  Basic example with styling # View.NavigationPage([ View.ContentPage( title = \u0026quot;ContentPage\u0026quot;, content = View.Label( horizontalOptions = model.MyStyle.Position, verticalOptions = model.MyStyle.Position, backgroundColor = model.MyStyle.ViewColor, padding = model.MyStyle.Padding, text = \u0026quot;NavigationPage with a single Label\u0026quot; ) ) ])  See also:\n Xamarin.Forms.NavigationPage  "}).add({id:50,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/openglview/",title:"OpenGLView",description:"Basic example # View.OpenGLView(hasRenderLoop = true)  Basic example with styling # View.OpenGLView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, margin = style.Thickness, hasRenderLoop = true )  See also:\n Xamarin.Forms.OpenGLView  ",content:"Basic example # View.OpenGLView(hasRenderLoop = true)  Basic example with styling # View.OpenGLView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, margin = style.Thickness, hasRenderLoop = true )  See also:\n Xamarin.Forms.OpenGLView  "}).add({id:51,href:"https://fsprojects.github.io/Fabulous/docs/v1/extensions/oxyplot/",title:"OxyPlot",description:"Below is an example of an extension for OxyPlot. To use the extension:\n Follow the instructions to add references and initialize renderers Add a reference to the Fabulous.XamarinForms.OxyPlot package across your solution.  \nHere is an example translated from the OxyPlot documentation.\nlet plotModelCos = let model = PlotModel(Title = \u0026quot;Example 1\u0026quot;) model.Series.Add(new OxyPlot.Series.FunctionSeries(Math.Cos, 0.0, 10.0, 0.1, \u0026quot;cos(x)\u0026quot;)) model let plotModelHeatMap = let model = PlotModel (Title = \u0026quot;Heatmap\u0026quot;) model.",content:"Below is an example of an extension for OxyPlot. To use the extension:\n Follow the instructions to add references and initialize renderers Add a reference to the Fabulous.XamarinForms.OxyPlot package across your solution.  \nHere is an example translated from the OxyPlot documentation.\nlet plotModelCos = let model = PlotModel(Title = \u0026quot;Example 1\u0026quot;) model.Series.Add(new OxyPlot.Series.FunctionSeries(Math.Cos, 0.0, 10.0, 0.1, \u0026quot;cos(x)\u0026quot;)) model let plotModelHeatMap = let model = PlotModel (Title = \u0026quot;Heatmap\u0026quot;) model.Axes.Add(LinearColorAxis (Palette = OxyPalettes.Rainbow(100))) let singleData = [ for x in 0 .. 99 -\u0026gt; Math.Exp((-1.0 / 2.0) * Math.Pow(((double)x - 50.0) / 20.0, 2.0)) ] let data = Array2D.init 100 100 (fun x y -\u0026gt; singleData.[x] * singleData.[(y + 30) % 100] * 100.0) let heatMapSeries = HeatMapSeries(X0 = 0.0, X1 = 99.0, Y0 = 0.0, Y1 = 99.0, Interpolate = true, RenderMethod = HeatMapRenderMethod.Bitmap, Data = data) model.Series.Add(heatMapSeries) model let plotModels = [ plotModelCos; plotModelHeatMap ] let view (model: Model) dispatch = View.CarouselPage(children= [ for m in plotModels -\u0026gt; View.ContentPage(content = View.PlotView(model=m, horizontalOptions=LayoutOptions.FillAndExpand, verticalOptions=LayoutOptions.FillAndExpand)) ])  See also:\n Interface Objects View Extensions  "}).add({id:52,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/path/",title:"Path",description:"Basic example # View.Path( stroke = View.SolidColorBrush(Color.Black), data = Content.fromString \u0026quot;M 10,100 C 100,0 200,200 300,100\u0026quot; )  Basic example with styling # View.Path( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, stroke = View.SolidColorBrush(Color.Black), data = Content.fromString \u0026quot;M 10,100 C 100,0 200,200 300,100\u0026quot; )  See also:\n Path in Xamarin Forms Xamarin.Forms.Path  More examples # Path can be used to draw curves and complex shapes. These curves and shapes are often described using Geometry objects.",content:"Basic example # View.Path( stroke = View.SolidColorBrush(Color.Black), data = Content.fromString \u0026quot;M 10,100 C 100,0 200,200 300,100\u0026quot; )  Basic example with styling # View.Path( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, stroke = View.SolidColorBrush(Color.Black), data = Content.fromString \u0026quot;M 10,100 C 100,0 200,200 300,100\u0026quot; )  See also:\n Path in Xamarin Forms Xamarin.Forms.Path  More examples # Path can be used to draw curves and complex shapes. These curves and shapes are often described using Geometry objects.\n// Path View.Path( stroke = View.SolidColorBrush(Color.Black), aspect = Stretch.Uniform, horizontalOptions = LayoutOptions.Center, data = Content.fromString \u0026quot;M 10,50 L 200,70\u0026quot; ) // Cubic Bezier Path View.Path( stroke = View.SolidColorBrush(Color.Black), aspect = Stretch.Uniform, horizontalOptions = LayoutOptions.Center, data = Content.fromString \u0026quot;M 10,100 C 100,0 200,200 300,100\u0026quot; )  "}).add({id:53,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/picker/",title:"Picker",description:"Basic example # let pickerItems = [ (\u0026quot;Aqua\u0026quot;, Color.Aqua); (\u0026quot;Black\u0026quot;, Color.Black); (\u0026quot;Blue\u0026quot;, Color.Blue); (\u0026quot;Fucshia\u0026quot;, Color.Fuchsia); (\u0026quot;Gray\u0026quot;, Color.Gray); (\u0026quot;Green\u0026quot;, Color.Green); (\u0026quot;Lime\u0026quot;, Color.Lime); (\u0026quot;Maroon\u0026quot;, Color.Maroon); (\u0026quot;Navy\u0026quot;, Color.Navy); (\u0026quot;Olive\u0026quot;, Color.Olive); (\u0026quot;Purple\u0026quot;, Color.Purple); (\u0026quot;Red\u0026quot;, Color.Red); (\u0026quot;Silver\u0026quot;, Color.Silver); (\u0026quot;Teal\u0026quot;, Color.Teal); (\u0026quot;White\u0026quot;, Color.White); (\u0026quot;Yellow\u0026quot;, Color.Yellow ) ] let pickedColorIndex = 2 // placeholder for demonstration purposes View.ContentPage(title =\u0026quot;Picker\u0026quot;, content = View.Picker( title = \u0026quot;Choose Color:\u0026quot;, textColor = snd pickerItems.[pickedColorIndex], selectedIndex = pickedColorIndex, items = List.map fst pickerItems ) )  See also:",content:"Basic example # let pickerItems = [ (\u0026quot;Aqua\u0026quot;, Color.Aqua); (\u0026quot;Black\u0026quot;, Color.Black); (\u0026quot;Blue\u0026quot;, Color.Blue); (\u0026quot;Fucshia\u0026quot;, Color.Fuchsia); (\u0026quot;Gray\u0026quot;, Color.Gray); (\u0026quot;Green\u0026quot;, Color.Green); (\u0026quot;Lime\u0026quot;, Color.Lime); (\u0026quot;Maroon\u0026quot;, Color.Maroon); (\u0026quot;Navy\u0026quot;, Color.Navy); (\u0026quot;Olive\u0026quot;, Color.Olive); (\u0026quot;Purple\u0026quot;, Color.Purple); (\u0026quot;Red\u0026quot;, Color.Red); (\u0026quot;Silver\u0026quot;, Color.Silver); (\u0026quot;Teal\u0026quot;, Color.Teal); (\u0026quot;White\u0026quot;, Color.White); (\u0026quot;Yellow\u0026quot;, Color.Yellow ) ] let pickedColorIndex = 2 // placeholder for demonstration purposes View.ContentPage(title =\u0026quot;Picker\u0026quot;, content = View.Picker( title = \u0026quot;Choose Color:\u0026quot;, textColor = snd pickerItems.[pickedColorIndex], selectedIndex = pickedColorIndex, items = List.map fst pickerItems ) )  See also:\n Picker in Xamarin Forms Xamarin.Forms.Picker  More examples # "}).add({id:54,href:"https://fsprojects.github.io/Fabulous/docs/v1/tutorials/dev-pitfalls/",title:"Pitfalls and F# 5.0 support",description:"Here are some common pitfalls you might encounter when using Fabulous.\nCan Fabulous target .NET 5 / use .NET 5 libraries? # Microsoft announced .NET 5 along with F# 5.0 during .NET Conf 2020.\nBefore .NET 5 came, there were 3 differents .NET frameworks: .NET Framework, .NET Core and Mono.\nHistorically, all Xamarin projects (Android, iOS, macOS and many other) run on Mono.\nSince Fabulous.XamarinForms is built on top of Xamarin.",content:"Here are some common pitfalls you might encounter when using Fabulous.\nCan Fabulous target .NET 5 / use .NET 5 libraries? # Microsoft announced .NET 5 along with F# 5.0 during .NET Conf 2020.\nBefore .NET 5 came, there were 3 differents .NET frameworks: .NET Framework, .NET Core and Mono.\nHistorically, all Xamarin projects (Android, iOS, macOS and many other) run on Mono.\nSince Fabulous.XamarinForms is built on top of Xamarin.Forms, it also shares the same framework.\nThis new framework marks the deprecation of .NET Framework in favor of .NET Core, this replacement is done under a new name: .NET 5.\nFor the moment, Mono is still an independent framework and hence is not compatible with .NET 5.\nMicrosoft is planning to retire Mono and use the same framework for everything including Xamarin when .NET 6 comes out (planned for the end of 2021).\nIn the meantime, it is recommended you target either .NET Standard 2.0 or 2.1 so you can share code between .NET 5 apps and Fabulous apps.\nCan Fabulous use F# 5.0? # Yes!\nYou can use any of the new features of F# 5.0 with Fabulous.\nBut the reality of the moment is that the support is largely dependent on your IDE.\nAs of January 2021, here is the support level we noticed for the various IDEs:\n  Visual Studio (Windows)\nWorks perfectly out of the box with Visual Studio 16.8 or newer.\nKnown issues:\n  Android projects might fail to build because of an issue with Xamarin.Android.FSharp.ResourceProvider. A known workaround is to remove System and System.Numerics from the Android project references.\nThis issue only affects VS 16.8. So lower versions will require System and System.Numerics to build.\n  iOS projects may fail after updating FSharp.Core. You will see an exception about a missing ValueOption type. This is caused by VS making a breaking change to the iOS fsproj file.\nThis block:\n  \u0026lt;Reference Include=\u0026quot;FSharp.Core\u0026quot;\u0026gt; \u0026lt;HintPath\u0026gt;..\\packages\\FSharp.Core.4.7.2\\lib\\netstandard2.0\\FSharp.Core.dll\u0026lt;/HintPath\u0026gt; \u0026lt;/Reference\u0026gt;  gets replaced with this:\n\u0026lt;Reference Include=\u0026quot;FSharp.Core\u0026quot;\u0026gt; \u0026lt;Private\u0026gt;True\u0026lt;/Private\u0026gt; \u0026lt;/Reference\u0026gt;  There is a simple fix - reverse the change in the proj file, but update the FSharp.Core.4.7.2 part of the hint path to the new version you have just installed.\n  Visual Studio (macOS)\nThe current stable release of Visual Studio for Mac 8.8.4 doesn\u0026rsquo;t fully support F# 5.0.\nYou can compile and debug F# 5.0 apps with it, but the syntax highlighting is broken if you try to use F# 5.0 features (like open type or string interpolation), which severely impede the development experience.\nKnown issues:\n Syntax highlighting is broken when using new features like string interpolation. There is no workaround for it. We need to wait for Microsoft to fix that. Hopefully with VS Mac 8.9.    JetBrains Rider (Windows \u0026amp; macOS)\nWorks perfectly out of the box with Jetbrains Rider 2020.3 or newer.\n  "}).add({id:55,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/polygon/",title:"Polygon",description:"Basic example # View.Polygon( points = Points.fromString \u0026quot;40,10 70,80 10,50\u0026quot;, fill = View.SolidColorBrush(Color.Black), stroke = View.SolidColorBrush(Color.Orange), strokeThickness = 5. )  Basic example with styling # View.Polygon( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, margin = style.Thickness, points = Points.fromString \u0026quot;40,10 70,80 10,50\u0026quot;, fill = View.SolidColorBrush(Color.Black), stroke = View.SolidColorBrush(Color.Orange), strokeThickness = 5. )  See also:\n Polygon in Xamarin Forms Xamarin.Forms.Polygon  More examples # Polygon can be used to draw polygons, which are connected series of lines that form closed shapes.",content:"Basic example # View.Polygon( points = Points.fromString \u0026quot;40,10 70,80 10,50\u0026quot;, fill = View.SolidColorBrush(Color.Black), stroke = View.SolidColorBrush(Color.Orange), strokeThickness = 5. )  Basic example with styling # View.Polygon( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, margin = style.Thickness, points = Points.fromString \u0026quot;40,10 70,80 10,50\u0026quot;, fill = View.SolidColorBrush(Color.Black), stroke = View.SolidColorBrush(Color.Orange), strokeThickness = 5. )  See also:\n Polygon in Xamarin Forms Xamarin.Forms.Polygon  More examples # Polygon can be used to draw polygons, which are connected series of lines that form closed shapes.\nlet polygonPoints1 = \u0026quot;40,10 70,80 10,50\u0026quot; let polygonPoints2 = \u0026quot;0 48, 0 144, 96 150, 100 0, 192 0, 192 96, 50 96, 48 192, 150 200 144 48\u0026quot; // Polygon\u0026quot; View.Polygon( points = Points.fromString polygonPoints1, fill = View.SolidColorBrush(Color.AliceBlue), stroke = View.SolidColorBrush(Color.Green), strokeThickness = 5. ) // Polygon with dashed stroke View.Polygon( points = Points.fromString polygonPoints1, fill = View.SolidColorBrush(Color.AliceBlue), stroke = View.SolidColorBrush(Color.Green), strokeThickness = 5., strokeDashArray = [ 1.; 1. ], strokeDashOffset = 6. ) // EvenOdd polygon View.Polygon( points = Points.fromString polygonPoints2, fill = View.SolidColorBrush(Color.Blue), fillRule = Shapes.FillRule.EvenOdd, stroke = View.SolidColorBrush(Color.Red), strokeThickness = 3. ) // NonZero polygon View.Polygon( points = Points.fromString polygonPoints2, fill = View.SolidColorBrush(Color.Black), fillRule = Shapes.FillRule.Nonzero, stroke = View.SolidColorBrush(Color.Yellow), strokeThickness = 3. )  "}).add({id:56,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/polyline/",title:"Polyline",description:"Basic example # View.Polyline( points = Points.fromString \u0026quot;0,0 10,30, 15,0 18,60 23,30 35,30 40,0 43,60 48,30 100,30\u0026quot;, stroke = View.SolidColorBrush(Color.Black), strokeThickness = 1. )  Basic example with styling # View.Polyline( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, margin = style.Thickness, points = Points.fromString \u0026quot;0,0 10,30, 15,0 18,60 23,30 35,30 40,0 43,60 48,30 100,30\u0026quot;, stroke = View.SolidColorBrush(Color.Black), strokeThickness = 1. )  See also:\n Polyline in Xamarin Forms Xamarin.",content:"Basic example # View.Polyline( points = Points.fromString \u0026quot;0,0 10,30, 15,0 18,60 23,30 35,30 40,0 43,60 48,30 100,30\u0026quot;, stroke = View.SolidColorBrush(Color.Black), strokeThickness = 1. )  Basic example with styling # View.Polyline( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, margin = style.Thickness, points = Points.fromString \u0026quot;0,0 10,30, 15,0 18,60 23,30 35,30 40,0 43,60 48,30 100,30\u0026quot;, stroke = View.SolidColorBrush(Color.Black), strokeThickness = 1. )  See also:\n Polyline in Xamarin Forms Xamarin.Forms.Polyline  More examples # Polyline can be used to draw a series of connected straight lines. A polyline is similar to a polygon, except the last point in a polyline is not connected to the first point.\nlet polylinePoints1 = \u0026quot;0,0 10,30, 15,0 18,60 23,30 35,30 40,0 43,60 48,30 100,30\u0026quot; let polylinePoints2 = \u0026quot;0 48, 0 144, 96 150, 100 0, 192 0, 192 96, 50 96, 48 192, 150 200 144 48\u0026quot; let polylinePoints3 = \u0026quot;20 20,250 50,20 120\u0026quot; // Polygon View.Polyline( points = Points.fromString polylinePoints1, stroke = View.SolidColorBrush(Color.Red), strokeThickness = 1. ) // Polyline with dashed stroke View.Polyline( points = Points.fromString polylinePoints1, stroke = View.SolidColorBrush(Color.Red), strokeThickness = 2., strokeDashArray = [ 1.; 1. ], strokeDashOffset = 6. ) // EvenOdd polyline View.Polyline( points = Points.fromString polylinePoints2, fill = View.SolidColorBrush(Color.Blue), fillRule = Shapes.FillRule.EvenOdd, stroke = View.SolidColorBrush(Color.Red), strokeThickness = 3. ) // NonZero polyline View.Polyline( points = Points.fromString polylinePoints2, fill = View.SolidColorBrush(Color.Black), fillRule = Shapes.FillRule.Nonzero, stroke = View.SolidColorBrush(Color.Yellow), strokeThickness = 3. ) // LineJoin: Miter View.Polyline( points = Points.fromString polylinePoints3, stroke = View.SolidColorBrush(Color.DarkBlue), strokeThickness = 20., strokeLineJoin = Shapes.PenLineJoin.Miter ) // LineJoin: Bevel View.Polyline( points = Points.fromString polylinePoints3, stroke = View.SolidColorBrush(Color.DarkBlue), strokeThickness = 20., strokeLineJoin = Shapes.PenLineJoin.Bevel ) // LineJoin: Round View.Polyline( points = Points.fromString polylinePoints3, stroke = View.SolidColorBrush(Color.DarkBlue), strokeThickness = 20., strokeLineJoin = Shapes.PenLineJoin.Round )  "}).add({id:57,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/popups/",title:"Pop-ups",description:"Pop-ups are a special case in Fabulous for Xamarin.Forms: they are part of the view, but don\u0026rsquo;t follow the same lifecycle as the rest of the UI. In Xamarin.Forms pop-ups are exposed through 2 methods of the current page: DisplayAlert and DisplayActionSheet.\nIn Fabulous for Xamarin.Forms we only describe what a page should look like and have no access to UI elements. As such, there is no direct implementation of those 2 methods in Fabulous but instead we can use the static property Application.",content:"Pop-ups are a special case in Fabulous for Xamarin.Forms: they are part of the view, but don\u0026rsquo;t follow the same lifecycle as the rest of the UI. In Xamarin.Forms pop-ups are exposed through 2 methods of the current page: DisplayAlert and DisplayActionSheet.\nIn Fabulous for Xamarin.Forms we only describe what a page should look like and have no access to UI elements. As such, there is no direct implementation of those 2 methods in Fabulous but instead we can use the static property Application.Current.MainPage exposed by Xamarin.Forms.\nHere is an example of the use of a confirmation pop-up - note the requirement of Cmd.AsyncMsg so as not to block on the UI thread:\ntype Msg = | DisplayAlert | AlertResult of bool let update (msg : Msg) (model : Model) = match msg with | DisplayAlert -\u0026gt; let alertResult = async { let! alert = Application.Current.MainPage.DisplayAlert(\u0026quot;Display Alert\u0026quot;, \u0026quot;Confirm\u0026quot;, \u0026quot;Ok\u0026quot;, \u0026quot;Cancel\u0026quot;) |\u0026gt; Async.AwaitTask return AlertResult alert } model, Cmd.ofAsyncMsg alertResult | AlertResult alertResult -\u0026gt; ... // Do something with the result  Why don\u0026rsquo;t we add a Fabulous wrapper for those? Doing so would only end up duplicating the existing methods and compel us to maintain these in sync with Xamarin.Forms. See Pull Request #147 for more information\nSee also:\n Displaying Pop-ups Xamarin.Forms.Core.Page.DisplayAlert Xamarin.Forms.Core.Page.DisplayActionSheet  "}).add({id:58,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/progressbar/",title:"ProgressBar",description:"Basic example # View.ProgressBar(progress = 0.5)  Basic example with styling # View.ProgressBar( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, progress = 0.5 )  See also:\n ProgressBar in Xamarin Forms Xamarin.Forms.ProgressBar  ",content:"Basic example # View.ProgressBar(progress = 0.5)  Basic example with styling # View.ProgressBar( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, progress = 0.5 )  See also:\n ProgressBar in Xamarin Forms Xamarin.Forms.ProgressBar  "}).add({id:59,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/radiobutton/",title:"RadioButton",description:"Basic example # View.StackLayout([ View.RadioButton(Content.String \u0026quot;RadioButton 1\u0026quot;) View.RadioButton(Content.String \u0026quot;RadioButton 2\u0026quot;) ])  Basic example with styling # View.StackLayout( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, children = [ View.RadioButton( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, isChecked = true, content = Content.String \u0026quot;RadioButton 1\u0026quot; ) View.RadioButton( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, isChecked = false, content = Content.",content:"Basic example # View.StackLayout([ View.RadioButton(Content.String \u0026quot;RadioButton 1\u0026quot;) View.RadioButton(Content.String \u0026quot;RadioButton 2\u0026quot;) ])  Basic example with styling # View.StackLayout( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, children = [ View.RadioButton( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, isChecked = true, content = Content.String \u0026quot;RadioButton 1\u0026quot; ) View.RadioButton( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, isChecked = false, content = Content.String \u0026quot;RadioButton 2\u0026quot; ) ] )  See also:\n RadioButton in Xamarin Forms Xamarin.Forms.RadioButton  More examples # View.StackLayout([ // These RadioButtons will be grouped together, beacause they are in the same StackLayout View.RadioButton( padding = Thickness 2.0, content = Content.String(\u0026quot;content1\u0026quot;), isChecked = true checkedChanged = (fun on -\u0026gt; dispatch (...)) ) View.RadioButton( padding = Thickness 2.0, content = Content.String(\u0026quot;content2\u0026quot;), isChecked = false checkedChanged = (fun on -\u0026gt; dispatch (...)) ) ])  "}).add({id:60,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/rectangle/",title:"Rectangle",description:"Basic example # View.Rectangle( fill = View.SolidColorBrush(Color.Black), stroke = View.SolidColorBrush(Color.Orange), strokeThickness = 5., width = 150., height = 50. )  Basic example with styling # View.Rectangle( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, margin = style.Thickness, fill = View.SolidColorBrush(Color.Black), stroke = View.SolidColorBrush(Color.Orange), strokeThickness = 5., width = 150., height = 50. )  See also:\n Rectangle in Xamarin Forms Xamarin.Forms.Rectangle  More examples # Rectangle can be used to draw rectangles and squares.",content:"Basic example # View.Rectangle( fill = View.SolidColorBrush(Color.Black), stroke = View.SolidColorBrush(Color.Orange), strokeThickness = 5., width = 150., height = 50. )  Basic example with styling # View.Rectangle( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, margin = style.Thickness, fill = View.SolidColorBrush(Color.Black), stroke = View.SolidColorBrush(Color.Orange), strokeThickness = 5., width = 150., height = 50. )  See also:\n Rectangle in Xamarin Forms Xamarin.Forms.Rectangle  More examples # Rectangle can be used to draw rectangles and squares.\n// Filled rectangle View.Rectangle( fill = View.SolidColorBrush(Color.Red), width = 150., height = 50., horizontalOptions = LayoutOptions.Start ) // Square View.Rectangle( stroke = View.SolidColorBrush(Color.Red), strokeThickness = 4., width = 150., height = 150., horizontalOptions = LayoutOptions.Start ) // Rectangle with stroke View.Rectangle( stroke = View.SolidColorBrush(Color.Red), strokeThickness = 4., width = 150., height = 50., horizontalOptions = LayoutOptions.Start ) // Filled rectangle with stroke View.Rectangle( fill = View.SolidColorBrush(Color.DarkBlue), stroke = View.SolidColorBrush(Color.Red), strokeThickness = 4., width = 150., height = 50., horizontalOptions = LayoutOptions.Start ) // Filled rectangle with dashed stroke View.Rectangle( fill = View.SolidColorBrush(Color.DarkBlue), stroke = View.SolidColorBrush(Color.Red), strokeThickness = 4., strokeDashArray = [ 1.; 1. ], strokeDashOffset = 6., width = 150., height = 50., horizontalOptions = LayoutOptions.Start ) // Rectangle with rounded corners View.Rectangle( fill = View.SolidColorBrush(Color.Blue), stroke = View.SolidColorBrush(Color.Black), strokeThickness = 3., radiusX = 50., radiusY = 10., width = 200., height = 100., horizontalOptions = LayoutOptions.Start )  "}).add({id:61,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/refreshview/",title:"RefreshVIew",description:"Basic example # View.RefreshView( View.ListView([ View.TextCell(\u0026quot;First item\u0026quot;) View.TextCell(\u0026quot;Second item\u0026quot;) View.TextCell(\u0026quot;Third item\u0026quot;) ]) )  Basic example with styling # View.RefreshView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, padding = style.Padding, content = View.ListView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, items = [ View.TextCell(\u0026quot;First item\u0026quot;) View.TextCell(\u0026quot;Second item\u0026quot;) View.TextCell(\u0026quot;Third item\u0026quot;) ] ) )  See also:\n RefreshView in Xamarin Forms Xamarin.Forms.RefreshView  More examples # The RefreshView is a container control that provides pull to refresh functionality for scrollable content.",content:"Basic example # View.RefreshView( View.ListView([ View.TextCell(\u0026quot;First item\u0026quot;) View.TextCell(\u0026quot;Second item\u0026quot;) View.TextCell(\u0026quot;Third item\u0026quot;) ]) )  Basic example with styling # View.RefreshView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, padding = style.Padding, content = View.ListView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, items = [ View.TextCell(\u0026quot;First item\u0026quot;) View.TextCell(\u0026quot;Second item\u0026quot;) View.TextCell(\u0026quot;Third item\u0026quot;) ] ) )  See also:\n RefreshView in Xamarin Forms Xamarin.Forms.RefreshView  More examples # The RefreshView is a container control that provides pull to refresh functionality for scrollable content. Therefore, the child of a RefreshView must be a scrollable control, such as ScrollView, CollectionView, or ListView.\nView.RefreshView( View.ScrollView( View.BoxView( height = 150., width = 150., color = if model.IsRefreshing then Color.Red else Color.Blue ) ), isRefreshing = model.IsRefreshing, refreshing = (fun () -\u0026gt; dispatch Refresh) )  "}).add({id:62,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/searchbar/",title:"SearchBar",description:"Basic example # View.SearchBar(placeholder = \u0026quot;SearchBar\u0026quot;)  Basic example with styling # View.SearchBar( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, placeholder = \u0026quot;SearchBar\u0026quot; )  See also:\n SearchBar in Xamarin Forms Xamarin.Forms.SearchBar  More examples # A simple SearchBar is as follows:\nView.SearchBar( placeholder = \u0026quot;Enter search term\u0026quot;, searchCommand = (fun searchBarText -\u0026gt; dispatch (ExecuteSearch searchBarText)), searchCommandCanExecute=true )  ",content:"Basic example # View.SearchBar(placeholder = \u0026quot;SearchBar\u0026quot;)  Basic example with styling # View.SearchBar( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, placeholder = \u0026quot;SearchBar\u0026quot; )  See also:\n SearchBar in Xamarin Forms Xamarin.Forms.SearchBar  More examples # A simple SearchBar is as follows:\nView.SearchBar( placeholder = \u0026quot;Enter search term\u0026quot;, searchCommand = (fun searchBarText -\u0026gt; dispatch (ExecuteSearch searchBarText)), searchCommandCanExecute=true )  "}).add({id:63,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/shell/",title:"Shell",description:"Xamarin.Forms Shell reduces the complexity of mobile application development by providing the fundamental features that most mobile applications require. This includes a common navigation user experience, a URI-based navigation scheme, and an integrated search handler.\nUnfortunately Shell is only partially supported in Fabulous for technical reasons, so it is recommended not to use it for the moment.\nView.Shell( title = \u0026quot;TitleShell\u0026quot;, items = [ View.FlyoutItem( title = \u0026quot;Flyout\u0026quot;, flyoutDisplayOptions = FlyoutDisplayOptions.",content:"Xamarin.Forms Shell reduces the complexity of mobile application development by providing the fundamental features that most mobile applications require. This includes a common navigation user experience, a URI-based navigation scheme, and an integrated search handler.\nUnfortunately Shell is only partially supported in Fabulous for technical reasons, so it is recommended not to use it for the moment.\nView.Shell( title = \u0026quot;TitleShell\u0026quot;, items = [ View.FlyoutItem( title = \u0026quot;Flyout\u0026quot;, flyoutDisplayOptions = FlyoutDisplayOptions.AsMultipleItems, items = [ View.Tab( title = \u0026quot;Seiten\u0026quot;, items = [ View.ShellContent( title = \u0026quot;welcome\u0026quot;, content = View.ContentPage( View.Label(\u0026quot;welcome ...\u0026quot;) ) ) View.ShellContent( title = \u0026quot;stuff\u0026quot;, content = View.ContentPage( View.Label(\u0026quot;stuff ...\u0026quot;) ) ) ] ) View.ShellContent( title = \u0026quot;more\u0026quot;, content = View.ContentPage( View.Label(\u0026quot;more stuff ...\u0026quot;) ) ) ] ) View.MenuItem(text = \u0026quot;config\u0026quot;) ] )  See also:\n Xamarin guide to Shell Xamarin.Forms.Core.Shell  "}).add({id:64,href:"https://fsprojects.github.io/Fabulous/docs/v1/extensions/skiasharp/",title:"SkiaSharp",description:"SkiaSharp is a 2D graphics system for .NET powered by the open-source Skia graphics engine that is used extensively in Google products. You can use SkiaSharp in your Xamarin.Forms applications to draw 2D vector graphics, bitmaps, and text.\nThe nuget Fabulous.XamarinForms.SkiaSharp implements a view component for the type SKCanvasView.\n  \nTo use Fabulous.XamarinForms.SkiaSharp, you must\n Add a reference to SkiaSharp.Views.Forms across your whole solution. This will add appropriate references to your platform-specific Android and iOS projects too.",content:"SkiaSharp is a 2D graphics system for .NET powered by the open-source Skia graphics engine that is used extensively in Google products. You can use SkiaSharp in your Xamarin.Forms applications to draw 2D vector graphics, bitmaps, and text.\nThe nuget Fabulous.XamarinForms.SkiaSharp implements a view component for the type SKCanvasView.\n  \nTo use Fabulous.XamarinForms.SkiaSharp, you must\n Add a reference to SkiaSharp.Views.Forms across your whole solution. This will add appropriate references to your platform-specific Android and iOS projects too. Next add a reference to Fabulous.XamarinForms.SkiaSharp across your whole solution.  After these steps you can use SkiaSharp in your view function. Here is a simple example of using SkiaSharp to draw a circle and respond to touch events:\nopen Fabulous.XamarinForms View.SKCanvasView(enableTouchEvents = true, paintSurface = (fun args -\u0026gt; let info = args.Info let surface = args.Surface let canvas = surface.Canvas canvas.Clear() use paint = new SKPaint(Style = SKPaintStyle.Stroke, Color = Color.Red.ToSKColor(), StrokeWidth = 25.0f) canvas.DrawCircle(float32 (info.Width / 2), float32 (info.Height / 2), 100.0f, paint) ), touch = (fun args -\u0026gt; printfn \u0026quot;touch event at (%f, %f)\u0026quot; args.Location.X args.Location.Y ) )  By default, the view will not be redrawn when the model changes. You should set invalidate to true when you know that a redraw is needed. Set it back to false when done, otherwise it will be redrawn at each update.\nView.SKCanvasView(..., invalidate = true)  See also:\n Interface Objects. Using SkiaSharp in Xamarin.Forms. Source for the SkiaSharp extension Defining Extensions  "}).add({id:65,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/slider/",title:"Slider",description:"Basic example # View.Slider( 5.0 )  Basic example with styling # View.Slider( backgroundColor = style.ViewColor, minimumMaximum = (0.0, 10.0), value = 5.0 )  See also:\n Xamarin.Forms.Slider  More examples # View.Slider( minimumMaximum = (0.0, 10.0), value = double step, valueChanged = (fun args -\u0026gt; dispatch (SliderValueChanged (int (args.NewValue + 0.5)))) )  ",content:"Basic example # View.Slider( 5.0 )  Basic example with styling # View.Slider( backgroundColor = style.ViewColor, minimumMaximum = (0.0, 10.0), value = 5.0 )  See also:\n Xamarin.Forms.Slider  More examples # View.Slider( minimumMaximum = (0.0, 10.0), value = double step, valueChanged = (fun args -\u0026gt; dispatch (SliderValueChanged (int (args.NewValue + 0.5)))) )  "}).add({id:66,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/stepper/",title:"Stepper",description:"Basic example # View.Stepper( 5.0 )  Basic example with styling # View.Stepper( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, minimumMaximum = (0.0, 10.0), value = 5.0 )  See also:\n Xamarin.Forms.Stepper  More examples # Use a Stepper for selecting a numeric value from a range of values.\nView.Stepper( minimumMaximum = (0.0, 10.0), value = 2., increment = 1., valueChanged = fun args -\u0026gt; dispatch (SliderValueChanged (.",content:"Basic example # View.Stepper( 5.0 )  Basic example with styling # View.Stepper( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, minimumMaximum = (0.0, 10.0), value = 5.0 )  See also:\n Xamarin.Forms.Stepper  More examples # Use a Stepper for selecting a numeric value from a range of values.\nView.Stepper( minimumMaximum = (0.0, 10.0), value = 2., increment = 1., valueChanged = fun args -\u0026gt; dispatch (SliderValueChanged (...)) )  "}).add({id:67,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/styling/",title:"Styling",description:"F#-coded styling # The easiest approach is to manually code up styling simply by using normal F# programming to abstract away commonality between various parts of your view logic.\nFor example, if a set of Labels share the same margin and color you can write this:\nlet styledLabel text = View.Label( text = text, margin = Thickness(0.0, 4.0), textColor = Color.Black ) styledLabel \u0026quot;This monkey is laid back and relaxed, and likes to watch the world go by.",content:"F#-coded styling # The easiest approach is to manually code up styling simply by using normal F# programming to abstract away commonality between various parts of your view logic.\nFor example, if a set of Labels share the same margin and color you can write this:\nlet styledLabel text = View.Label( text = text, margin = Thickness(0.0, 4.0), textColor = Color.Black ) styledLabel \u0026quot;This monkey is laid back and relaxed, and likes to watch the world go by.\u0026quot; styledLabel \u0026quot; - Often smiles mysteriously\u0026quot; styledLabel \u0026quot; - Sleeps sitting up\u0026quot;  We do not give a full guide here as it is routine application of F# coding.\nThere are many upsides to this approach. The downsides are:\n styling is done using F# coding, and some UI designers may prefer to work with CSS or another styling technique there is no easy way to provide default styling base on selectors like \u0026ldquo;All buttons\u0026rdquo; (except of course to carefully code your F# to make sure all button creations go through a particular helper) you may end up hand-rolling certain selector queries and patterns from other styling languages.  CSS styling with Xamarin.Forms 3.0 #  create a CSS file with appropriate selectors and property specifications. Add the style sheet to your app as an EmbeddedResource node. Load it into your app. Set styleClass for named elements.  For example, places the following CSS into MyProject.Assets.styles.css:\nstacklayout { margin: 20; } .mainPageTitle { font-style: bold; font-size: medium; } .detailPageTitle { font-style: bold; font-size: medium; text-align: center; }  Here stacklayout referes to all elements of that type, and .mainPageTitle refers to a specific element style-class path.\nThe CSS is added to the app in your main app code:\ntype App () as app = inherit Application () do app.Resources.Add(StyleSheet.FromAssemblyResource(Assembly.GetExecutingAssembly(),\u0026quot;MyProject.Assets.styles.css\u0026quot;))  Set the style classes as follows:\nView.Label(text=\u0026quot;Hello\u0026quot;, styleClass=\u0026quot;detailPageTitle\u0026quot;) ... View.Label(text=\u0026quot;Main Page\u0026quot;, styleClass=\u0026quot;mainPageTitle\u0026quot;)  You can also add style sheets for particular elements and their contents by using the styleSheets property for each visual element. For example:\n// Always define your style sheets as static values, sine their object identity is signficant! let styleSheet = StyleSheet.FromAssemblyResource(Assembly.GetExecutingAssembly(),\u0026quot;MyProject.Assets.styles.css\u0026quot;) let view model disptch = View.ContentPage(styleSheets=[myStyleSheet], ...)  \u0026ldquo;Xaml\u0026rdquo; coding via explicit Style objects # You can also use \u0026ldquo;Xaml styling\u0026rdquo; by creating specific Style objects using the Xamarin.Forms APIs directly and attaching them to your application. We don\u0026rsquo;t go into details here\n// Always define your styles as static values, sine their object identity is signficant! let style = Style... let view model disptch = View.ContentPage(styles=[myStyle], ...)  Resource Dictionaries # In Xamarin.Forms documentation you may see references to resource dictionaries. In Fabulous, resources dictionaries are replaced by \u0026ldquo;simple F# programming\u0026rdquo;, e.g.\nlet horzOptions = LayoutOptions.Center let vertOptions = LayoutOptions.CenterAndExpand  is basically the equivalent of Xaml:\n\u0026lt;ContentPage.Resources\u0026gt; \u0026lt;ResourceDictionary\u0026gt; \u0026lt;LayoutOptions x:Key=\u0026quot;horzOptions\u0026quot; Alignment=\u0026quot;Center\u0026quot; /\u0026gt; \u0026lt;LayoutOptions x:Key=\u0026quot;vertOptions\u0026quot; Alignment=\u0026quot;Center\u0026quot; Expands=\u0026quot;True\u0026quot; /\u0026gt; \u0026lt;/ResourceDictionary\u0026gt; \u0026lt;/ContentPage.Resources\u0026gt;  In other words, you can normally forget about resource dictionaries and just program as you would normally in F#.\nOther kinds of resources like images need a little more attention and you may need to ship multiple versions of images etc. for Android and iOS. TBD: write a guide on these, in the meantime see the samples.\nSee also:\n Xamarin.Forms styling  "}).add({id:68,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/swipeview/",title:"SwipeView",description:"Basic example # View.SwipeView( leftItems = View.SwipeItems([ View.SwipeItem(\u0026quot;Left 1\u0026quot;) View.SwipeItem(\u0026quot;Left 2\u0026quot;) ]), rightItems = View.SwipeItems([ View.SwipeItem(\u0026quot;Right 1\u0026quot;) View.SwipeItem(\u0026quot;Right 2\u0026quot;) ]), content = View.Grid( height = 60., width = 300., children = [ View.Label(\u0026quot;test\u0026quot;) ] ) )  Basic example with styling # View.SwipeView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, padding = style.Padding, leftItems = View.SwipeItems([ View.SwipeItem( backgroundColor = style.ViewColor, text = \u0026quot;Left 1\u0026quot; ) View.SwipeItem( backgroundColor = style.",content:"Basic example # View.SwipeView( leftItems = View.SwipeItems([ View.SwipeItem(\u0026quot;Left 1\u0026quot;) View.SwipeItem(\u0026quot;Left 2\u0026quot;) ]), rightItems = View.SwipeItems([ View.SwipeItem(\u0026quot;Right 1\u0026quot;) View.SwipeItem(\u0026quot;Right 2\u0026quot;) ]), content = View.Grid( height = 60., width = 300., children = [ View.Label(\u0026quot;test\u0026quot;) ] ) )  Basic example with styling # View.SwipeView( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.LayoutColor, padding = style.Padding, leftItems = View.SwipeItems([ View.SwipeItem( backgroundColor = style.ViewColor, text = \u0026quot;Left 1\u0026quot; ) View.SwipeItem( backgroundColor = style.ViewColor2, text = \u0026quot;Left 2\u0026quot; ) ]), rightItems = View.SwipeItems([ View.SwipeItem( backgroundColor = style.ViewColor3, text = \u0026quot;Right 1\u0026quot; ) View.SwipeItem( backgroundColor = style.ViewColor4, text = \u0026quot;Right 2\u0026quot; ) ]), content = View.Grid( height = 60., width = 300., children = [ View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;test\u0026quot; ) ] ) )  See also:\n SwipeView in Xamarin Forms Xamarin.Forms.SwipeView  More examples # The SwipeView is a container control that wraps around an item of content, and provides context menu items that are revealed by a swipe gesture:\nView.SwipeView( leftItems = View.SwipeItems([ View.SwipeItem(text = \u0026quot;Left 1\u0026quot;, backgroundColor = Color.LightPink) View.SwipeItem(text = \u0026quot;Left 2\u0026quot;, backgroundColor = Color.LightGreen) ]), rightItems = View.SwipeItems([ View.SwipeItem(text = \u0026quot;Right 1\u0026quot;, backgroundColor = Color.LightPink) View.SwipeItem(text = \u0026quot;Right 2\u0026quot;, backgroundColor = Color.LightGreen) ]), content = View.Grid( height = 60.0, width = 300.0, backgroundColor = Color.LightGray, children = [ View.BoxView(Color.Blue) ] ) )  "}).add({id:69,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/switch/",title:"Switch",description:"Basic example # View.Switch()  Basic example with styling # View.Switch( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, isToggled = false )  See also:\n Xamarin.Forms.Switch  More examples # Switch is a horizontal toggle button that can be manipulated by the user to toggle between on and off states, which are represented by a boolean value.\nView.Switch( isToggled = false, toggled = fun on -\u0026gt; dispatch (SwitchToggled (.",content:"Basic example # View.Switch()  Basic example with styling # View.Switch( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, isToggled = false )  See also:\n Xamarin.Forms.Switch  More examples # Switch is a horizontal toggle button that can be manipulated by the user to toggle between on and off states, which are represented by a boolean value.\nView.Switch( isToggled = false, toggled = fun on -\u0026gt; dispatch (SwitchToggled (...)) )  "}).add({id:70,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/tabbedpage/",title:"TabbedPage",description:"Basic example # View.TabbedPage([ View.ContentPage( title = \u0026quot;First Tab\u0026quot;, content = View.Label(\u0026quot;TabbedPage 1\u0026quot;) ) View.ContentPage( title = \u0026quot;Second Tab\u0026quot;, content = View.Label(\u0026quot;TabbedPage 2\u0026quot;) ) ])  Basic example with styling # View.TabbedPage( backgroundColor = style.PageColor, title = \u0026quot;TabbedPage\u0026quot;, children = [ View.ContentPage( title =\u0026quot;First Tab\u0026quot;, content = View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;TabbedPage 1\u0026quot; ) ) View.ContentPage( title =\u0026quot;Second Tab\u0026quot;, content = View.",content:"Basic example # View.TabbedPage([ View.ContentPage( title = \u0026quot;First Tab\u0026quot;, content = View.Label(\u0026quot;TabbedPage 1\u0026quot;) ) View.ContentPage( title = \u0026quot;Second Tab\u0026quot;, content = View.Label(\u0026quot;TabbedPage 2\u0026quot;) ) ])  Basic example with styling # View.TabbedPage( backgroundColor = style.PageColor, title = \u0026quot;TabbedPage\u0026quot;, children = [ View.ContentPage( title =\u0026quot;First Tab\u0026quot;, content = View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;TabbedPage 1\u0026quot; ) ) View.ContentPage( title =\u0026quot;Second Tab\u0026quot;, content = View.Label( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor, padding = style.Padding, text = \u0026quot;TabbedPage 2\u0026quot; ) ) ] )  See also:\n Xamarin.Forms.TabbedPage  "}).add({id:71,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/tableview/",title:"TableView",description:"Basic example # View.TableView( View.TableRoot([ View.TableSection( title = \u0026quot;TextCell\u0026quot;, items = [ View.TextCell(text = \u0026quot;First TextCell\u0026quot;) View.TextCell(text = \u0026quot;Second TextCell\u0026quot;) ] ) View.TableSection( title = \u0026quot;ImageCell\u0026quot;, items = [ View.ImageCell(text = \u0026quot;First ImageCell\u0026quot;, image = Image.ImagePath \u0026quot;icon.png\u0026quot;) View.ImageCell(text = \u0026quot;Second ImageCell\u0026quot;, image = Image.ImagePath \u0026quot;icon2.png\u0026quot;) ] ) View.TableSection( title = \u0026quot;SwitchCell\u0026quot;, items = [ View.SwitchCell(text = \u0026quot;First SwitchCell\u0026quot;, isEnabled = false) View.SwitchCell(text = \u0026quot;Second SwitchCell\u0026quot;, isEnabled = true) ] ) View.",content:"Basic example # View.TableView( View.TableRoot([ View.TableSection( title = \u0026quot;TextCell\u0026quot;, items = [ View.TextCell(text = \u0026quot;First TextCell\u0026quot;) View.TextCell(text = \u0026quot;Second TextCell\u0026quot;) ] ) View.TableSection( title = \u0026quot;ImageCell\u0026quot;, items = [ View.ImageCell(text = \u0026quot;First ImageCell\u0026quot;, image = Image.ImagePath \u0026quot;icon.png\u0026quot;) View.ImageCell(text = \u0026quot;Second ImageCell\u0026quot;, image = Image.ImagePath \u0026quot;icon2.png\u0026quot;) ] ) View.TableSection( title = \u0026quot;SwitchCell\u0026quot;, items = [ View.SwitchCell(text = \u0026quot;First SwitchCell\u0026quot;, isEnabled = false) View.SwitchCell(text = \u0026quot;Second SwitchCell\u0026quot;, isEnabled = true) ] ) View.TableSection( title = \u0026quot;EntryCell\u0026quot;, items = [ View.EntryCell(label = \u0026quot;First EntryCell\u0026quot;, placeholder = \u0026quot;enter text here\u0026quot;) View.EntryCell(label = \u0026quot;Second EntryCell\u0026quot;, placeholder = \u0026quot;enter more text here\u0026quot;) ] ) ]) )  See also:\n TableView in Xamarin Forms Xamarin.Forms.TableView  More examples # "}).add({id:72,href:"https://fsprojects.github.io/Fabulous/docs/v1/tutorials/dev-testing/",title:"Testing",description:"The Model-View-Update architecture used by Fabulous makes it simple to unit test every part of your application.\nApps are composed of 3 key pure F# functions: init, update and view\nThey take some parameters and return a value. Ideal for unit testing.\nTesting init # init is the easiest one to test.\nIt usually takes nothing and returns a value.\nLet\u0026rsquo;s take this code for example:\ntype Model = { Count: int Step: int } let init () = { Count = 0; Step = 1 }  Here we can make sure that the default state stays exact throughout the life of the project.",content:"The Model-View-Update architecture used by Fabulous makes it simple to unit test every part of your application.\nApps are composed of 3 key pure F# functions: init, update and view\nThey take some parameters and return a value. Ideal for unit testing.\nTesting init # init is the easiest one to test.\nIt usually takes nothing and returns a value.\nLet\u0026rsquo;s take this code for example:\ntype Model = { Count: int Step: int } let init () = { Count = 0; Step = 1 }  Here we can make sure that the default state stays exact throughout the life of the project.\nSo using our favorite unit test framework (here we use FsUnit for this example), we can write a test that will check if the value returned by init is the one we expect.\n[\u0026lt;Test\u0026gt;] let ``Init should return a valid initial state``() = App.init () |\u0026gt; should equal { Count = 0; Step = 1 }  Testing update # update can be more complex but it remains a pure F# function.\nTesting it is equivalent to what we just did with init.\nLet\u0026rsquo;s take this code for example:\ntype Model = { Count: int Step: int } type Msg = | Increment | Decrement | Reset let update msg model = match msg with | Increment -\u0026gt; { model with Count = model.Count + model.Step } | Decrement -\u0026gt; { model with Count = model.Count - model.Step } | Reset -\u0026gt; { model with Count = 0; Step = 1 }  We can write the following tests:\n[\u0026lt;Test\u0026gt;] let ``Given the message Increment, Update should increment Count by Step``() = let initialModel = { Count = 5; Step = 4 } let expectedModel = { Count = 9; Step = 4 } App.update Increment initialModel |\u0026gt; should equal expectedModel [\u0026lt;Test\u0026gt;] let ``Given the message Decrement, Update should decrement Count by Step``() = let initialModel = { Count = 5; Step = 4 } let expectedModel = { Count = 1; Step = 4 } App.update Decrement initialModel |\u0026gt; should equal expectedModel [\u0026lt;Test\u0026gt;] let ``Given the message Reset, Update should reset the state``() = let initialModel = { Count = 5; Step = 4 } let expectedModel = { Count = 0; Step = 1 } App.update Reset initialModel |\u0026gt; should equal expectedModel  Testing init and update when using commands # Testing Cmd\u0026lt;'msg\u0026gt; can be hard, because there\u0026rsquo;s no way of knowing what the functions inside Cmd really are before executing them.\nThe recommended way is to apply the CmdMsg pattern.\nSee Replacing commands with command messages for better testability\nTesting view # Views in Fabulous are testable as well, which makes it a clear advantage over more classic OOP frameworks (like C#/MVVM).\nThe view function returns a ViewElement value (which is a dictionary of attribute-value pairs). So we can check against that dictionary if we find the property we want, with the value we want.\nUnfortunately when creating a control through View.XXX, we lose the control\u0026rsquo;s type and access to its properties. Fabulous creates a ViewElement which encapsulates all those data.\nIn order to test in a safe way, Fabulous provides type-safe helpers for every controls from Xamarin.Forms.Core.\nYou can find them in the Fabulous.XamarinForms namespace. They are each named after the control they represent.\nExample: StackLayoutViewer will let you access the properties of a StackLayout.\nThe Viewer only takes a ViewElement as a parameter.\n(If you pass a ViewElement that represents a different control than the Viewer expects, the Viewer will throw an exception)\nLet\u0026rsquo;s take this code for example:\nlet view (model: Model) dispatch = View.ContentPage( content=View.StackLayout( automationId=\u0026quot;stackLayoutId\u0026quot; children=[ View.Label(automationId=\u0026quot;CountLabel\u0026quot;, text=sprintf \u0026quot;%d\u0026quot; model.Count) View.Button(text=\u0026quot;Increment\u0026quot;, command=(fun () -\u0026gt; dispatch Increment)) View.Button(text=\u0026quot;Decrement\u0026quot;, command=(fun () -\u0026gt; dispatch Decrement)) View.StackLayout( orientation=StackOrientation.Horizontal, children=[ View.Label(text=\u0026quot;Timer\u0026quot;) View.Switch(isToggled=model.TimerOn, toggled=(fun on -\u0026gt; dispatch (TimerToggled on.Value))) ]) View.Slider(minimumMaximum=(0.0, 10.0), value=double model.Step, valueChanged=(fun args -\u0026gt; dispatch (SetStep (int args.NewValue)))) View.Label(text=sprintf \u0026quot;Step size: %d\u0026quot; model.Step) ]))  We want to make sure that if the state changes, the view will update accordingly.\nThe first step is to call view with a given state and retrieve the generated ViewElement.\nview is expecting a dispatch function as well. In our case, we don\u0026rsquo;t need to test the dispatching of messages, so we pass the function ignore instead.\nFrom there, we create the Viewers to help us read the properties of the controls we want to check.\nAnd finally, we assert that the properties have the expected values.\nViewer API # The following approach uses the Viewer API. This is a way but with this you have to know exactly at which position the child you need is.\n[\u0026lt;Test\u0026gt;] let ``View should generate a label showing the count number of the model``() = let model = { Count = 5; Step = 4; TimerOn = true } let actualView = App.view model ignore let contentPage = ContentPageViewer(actualView) let stackLayout = StackLayoutViewer(contentPage.Content) let countLabel = LabelViewer(stackLayout.Children.[0]) countLabel.Text |\u0026gt; should equal \u0026quot;5\u0026quot;  FindViewElement / TryFindViewElement # With findViewElement and tryFindViewElement you don\u0026rsquo;t need to know where exactly the child is positioned. You have to set automationId on the ViewElements which will be used by those functions to find the element in the tree. This approach is the recommended way for testing and to get the ViewElements in a View.\nfindViewElement # [\u0026lt;Test\u0026gt;] let ``View should generate a label showing the count number of the model``() = let model = { Count = 5; Step = 4; TimerOn = true } let actualView = App.view model ignore let countLabel = findViewElement \u0026quot;CountLabel\u0026quot; actualView |\u0026gt; LabelViewer countLabel.Text |\u0026gt; should equal \u0026quot;5\u0026quot;  tryFindViewElement # tryFindViewElement delivers a quickaccess to a ViewElement as findViewElement but here you get an Option Type. With this you can also check for the existence of a ViewElement.\n[\u0026lt;Test\u0026gt;] let ``When user is authenticated, View should not include a connection button``() = let model = { Count = 5; Step = 4; TimerOn = true } let actualView = App.view model ignore tryFindViewElement \u0026quot;ConnectionButton\u0026quot; actualView |\u0026gt; should equal None  Testing if a control dispatches the correct message # If you want to test your event handlers, you can retrieve them in the same way than a regular property.\nThen, you can execute the event handler like a normal function and check its result through a mocked dispatch.\n[\u0026lt;Test\u0026gt;] let ``Clicking the button Increment should send the message Increment``() = let mockedDispatch msg = msg |\u0026gt; should equal Increment let model = { Count = 5; Step = 4; TimerOn = true } let actualView = App.view model mockedDispatch let contentPage = ContentPageViewer(actualView) let stackLayout = StackLayoutViewer(contentPage.Content) let incrementButton = ButtonViewer(stackLayout.Children.[1]) incrementButton.Command ()  See also #  CounterApp.Tests sample  "}).add({id:73,href:"https://fsprojects.github.io/Fabulous/docs/v1/tutorials/update/",title:"The Init and Update Functions",description:"The init function returns an initial model, and the update function processes a message and returns a new model:\ntype Model = { TimerOn: bool } type Message = | TimerToggled of bool let init () = { TimerOn = false } let update msg model = match msg with | TimerToggled on -\u0026gt; { model with TimerOn = on }  Commands # A command (type Cmd) is a callback that can dispatch messages, i.",content:"The init function returns an initial model, and the update function processes a message and returns a new model:\ntype Model = { TimerOn: bool } type Message = | TimerToggled of bool let init () = { TimerOn = false } let update msg model = match msg with | TimerToggled on -\u0026gt; { model with TimerOn = on }  Commands # A command (type Cmd) is a callback that can dispatch messages, i.e. gets access to dispatch when run.\nCommands can be used for event subscriptions to callback, implement timers and so on. They can also be returned with the model to queue up long running operations such as network calls.\nCommands are often asynchronous and nearly always dispatch messages. For example, the simplest way to make a command is Cmd.ofAsyncMsg which triggers a message dispatch when an async completes:\nlet timerCmd = async { do! Async.Sleep 200 return TimedTick } |\u0026gt; Cmd.ofAsyncMsg  Triggering Commands on Initialization # The init function may trigger commands, e.g. initial database requests. This is permitted when using Program.mkProgram. For example here is a pattern to get an initial balance on startup:\nlet fetchInitialBalance = Cmd.ofAsyncMsg (async { ... }) let init () = { ... }, fetchInitialBalance  Triggering Commands as Messages are Processed # The update function may trigger commands such as timers. This is permitted when using Program.mkProgram. For example, here is one pattern for a timer loop that can be turned on/off:\ntype Model = { TimerOn: bool Count: int Step: int } type Message = | TimedTick | TimerToggled of bool let timerCmd = async { do! Async.Sleep 200 return TimedTick } |\u0026gt; Cmd.ofAsyncMsg let init () = { TimerOn = false; Count = 0; Step = 1 }, Cmd.none let update msg model = match msg with | TimerToggled on -\u0026gt; { model with TimerOn = on }, (if on then timerCmd else Cmd.none) | TimedTick -\u0026gt; if model.TimerOn then { model with Count = model.Count + model.Step }, timerCmd else model, Cmd.none  Triggering Commands from External Events # You can also set up global subscriptions, which are events sent from outside the view or the dispatch loop. For example, dispatching ClockMsg messages on a global timer:\nlet timerTick dispatch = let timer = new System.Timers.Timer(1.0) timer.Elapsed.Subscribe (fun _ -\u0026gt; dispatch (ClockMsg System.DateTime.Now)) |\u0026gt; ignore timer.Enabled \u0026lt;- true timer.Start() let runner = Program.mkSimple App.init App.update App.view |\u0026gt; Program.withSubscription (fun _ -\u0026gt; Cmd.ofSub timerTick) |\u0026gt; Program.runWithDynamicView app  Likewise, the general pattern to subscribe to external event sources is as follows:\nlet subscribeToPushEvent dispatch = ... call dispatch in some closure ... let runner = Program.mkSimple App.init App.update App.view |\u0026gt; Program.withSubscription (fun _ -\u0026gt; Cmd.ofSub subscribeToPushEvent) |\u0026gt; Program.runWithDynamicView app  Everything that wants access to dispatch must be mentioned in the composition of the overall app, or as part of a command produced as a result of processing a message, or in the view.\nReplacing commands with command messages for better testability # Commands are a great way for executing a set of tasks (asynchronous or not) after receiving a message.\nBut behind the scenes, Cmd\u0026lt;'msg\u0026gt; is really only an array of functions. This makes testing Cmd\u0026lt;'msg\u0026gt; really difficult (no way to know what the functions are) and the functions init and update as well.\nIn the case you want to unit test your code, even if you\u0026rsquo;re using Cmd\u0026lt;'msg\u0026gt; inside init and update, the best way is to use of the CmdMsg pattern.\nThis is a general pattern, applicable when using an Elm-like programming model.\nIt is not linked to Fabulous specifically.\nFabulous only provides some helpers to help you achieve this with less code.\nThe principle is to replace any direct usage of Cmd\u0026lt;'msg\u0026gt; from init and update, and instead use a discriminated union called CmdMsg.\ntype Model = { TimerOn: bool Count: int Step: int } type Msg = | TimedTick | TimerToggled of bool type CmdMsg = | TimerTick let init () = { TimerOn = false; Count = 0; Step = 1 }, [] // An empty list means no action let update msg model = match msg with | TimerToggled on -\u0026gt; { model with TimerOn = on }, [ if on then yield TimerTick ] | TimedTick -\u0026gt; if model.TimerOn then { model with Count = model.Count + model.Step }, [ TimerTick ] else model, []  Doing this transforms the output of both init and update to pure data output, which can then be easily unit tested\n[\u0026lt;Test\u0026gt;] let togglingOnShouldTriggerTimerTick () = let initialModel = { TimerOn = false; Count = 0; Step = 1 } let expectedReturn = { TimerOn = true; Count = 0; Step = 1 }, [ TimerTick ] App.update (TimerToggled true) initialModel |\u0026gt; should equal expectedReturn  The actual commands are still executed as Cmd\u0026lt;'msg\u0026gt; though.\nSo in order to make this work with Fabulous, you need a function that will convert a CmdMsg to a Cmd\u0026lt;'msg\u0026gt;\nFabulous then helps you boot your application using Program.mkProgramWithCmdMsg\nlet mapCommands cmdMsg = match cmdMsg with | TimerTick -\u0026gt; timerCmd() type App() as app = inherit Application() let runner = Program.mkProgramWithCmdMsg init update view mapCommands |\u0026gt; XamarinFormsProgram.run app  Note that Program.mkProgramWithCmdMsg doesn\u0026rsquo;t do anything magic.\nIt only applies mapCommands to any CmdMsg returned by init and update.\nYou could achieve the exact same behavior by converting them yourself and using Program.mkProgram.\nThreading and Long-running Operations # The rules:\n update gets run on the UI thread. dispatch can be called from any thread. The message will be processed by update on the UI thread. view gets called on the UI thread. In the future an option may be added to offload the view function automatically.  When handling any long running operation, the operation should initiate it\u0026rsquo;s thing and dispatch a message when done. If necessary, explicitly off-load and then dispatch at the end, e.g.\nlet backgroundCmd = Cmd.ofAsyncMsg (async { do! Async.SwitchToThreadPool() let res = ... return msg })  Optional commands # There might be cases where before a message is sent, you need to check if you want to send it (e.g. check user\u0026rsquo;s preferences, ask user\u0026rsquo;s permission, \u0026hellip;)\nFabulous has 2 helper functions for this:\n Cmd.ofMsgOption  let autoSaveCmd = match userPreference.IsAutoSaveEnabled with | false -\u0026gt; None | true -\u0026gt; autoSave() Some Msg.AutoSaveDone let update msg model = match msg with | TimedTick -\u0026gt; model, (Cmd.ofMsgOption autoSaveCmd) | AutoSaveDone -\u0026gt; ...   Cmd.ofAsyncMsgOption  let takePictureCmd = async { try let! picture = takePictureAsync() Some (Msg.PictureTaken picture) with | exn -\u0026gt; do! displayAlert(\u0026quot;Exception: \u0026quot; + exn.Message) None } let update msg model = match msg with | TakePicture -\u0026gt; model, (Cmd.ofAsyncMsgOption takePictureCmd) | PictureTaken -\u0026gt; ...  Webrequests in a Command # Sometimes it is needed to make some web requests. Which tool you use here does not matter. For example you could use FSharp.Data to make HttpRequests. These are the steps that you have to do, to make it work:\n Create a case in the message type for a successful and failure webrequests  type Msg = | LoginClicked | LoginSuccess | AuthError   Implement the Command and return the correct message  let authUser (username : string) (password : string) = async { do! Async.SwitchToThreadPool() // make your http call // FSharp.Data.HTTPUtil is used here let! response = Http.AsyncRequest (url = URL, body = TextRequest \u0026quot;\u0026quot;\u0026quot; {\u0026quot;username\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;testpassword\u0026quot;} \u0026quot;\u0026quot;\u0026quot;, httpMethod = \u0026quot;POST\u0026quot;, silentHttpErrors = true) let r = match response.StatusCode with | 200 -\u0026gt; LoginSuccess | _ -\u0026gt; AuthError return r } |\u0026gt; Cmd.ofAsyncMsg   Call the Command from update e.g. when a button is clicked  let update msg model = match msg with | LoginClicked -\u0026gt; { model with IsRunning = true }, authUser model.Username model.Password // Call the Command | LoginSuccess -\u0026gt; { model with IsLoggedIn = true IsRunning = false }, Cmd.none | AuthError -\u0026gt; { model with IsLoggedIn = false IsRunning = false }, Cmd.none   Create your view as you need  match model.IsLoggedIn with | true -\u0026gt; LoggedInSuccesful | false -\u0026gt; LoginView  Platform-specific dispatch # Some platform-specific features (like deep linking, memory warnings, \u0026hellip;) are not available in Xamarin.Forms, and need you to implement them in the corresponding app projet.\nIn this case, you might want to dispatch a message from the app project to Fabulous to start a shared logic between platforms (to warn user, \u0026hellip;).\nTo allow for this kind of use case, the dispatch function is exposed as a Dispatch(msg) method by the ProgramRunner. By default this runner is not accessible, but you can make a read-only property to let apps access it.\ntype App() as app = inherit Application() let runner = Program.mkProgram init update view |\u0026gt; XamarinFormsProgram.run app member __.Program = runner // Add this line  Once done, you can access it in the app project\n Android  [\u0026lt;Activity\u0026gt;] type MainActivity() = inherit FormsApplicationActivity() // Store the App instance let mutable _app: App option = None override this.OnCreate (bundle: Bundle) = base.OnCreate (bundle) Forms.Init (this, bundle) // Initialize the app and store its reference let app = new App() this.LoadApplication(app) _app \u0026lt;- Some app override this.OnTrimMemory(level) = // If the app is initialized, dispatch the message match _app with | Some app -\u0026gt; app.Program.Dispatch(Msg.ReceivedLowMemoryWarning) | None -\u0026gt; ()   iOS  [\u0026lt;Register(\u0026quot;AppDelegate\u0026quot;)\u0026gt;] type AppDelegate () = inherit FormsApplicationDelegate () // Store the App instance let mutable _app: App option = None override this.FinishedLaunching (uiApp, options) = Forms.Init() // Initialize the app and store its reference let app = new AllControls.App() this.LoadApplication (app) _app \u0026lt;- Some app base.FinishedLaunching(uiApp, options) override this.ReceiveMemoryWarning(uiApp) = // If the app is initialized, dispatch the message match _app with | Some app -\u0026gt; app.Program.Dispatch(Msg.ReceivedLowMemoryWarning) | None -\u0026gt; ()  "}).add({id:74,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/timepicker/",title:"TimePicker",description:"Basic example # View.TimePicker()  Basic example with styling # View.TimePicker( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor )  See also:\n Xamarin.Forms.TimePicker  More examples # View.TimePicker( time = TimeSpan(12, 22, 0) )  ",content:"Basic example # View.TimePicker()  Basic example with styling # View.TimePicker( horizontalOptions = style.Position, verticalOptions = style.Position, backgroundColor = style.ViewColor )  See also:\n Xamarin.Forms.TimePicker  More examples # View.TimePicker( time = TimeSpan(12, 22, 0) )  "}).add({id:75,href:"https://fsprojects.github.io/Fabulous/docs/v1/tutorials/dev-logging/",title:"Traces and crashes",description:"In Fabulous, everything happens in a centralized message loop that is responsible for calling your init, update and view functions.\nFabulous allows you to plug into this loop to run custom logic such as logging and error handling.\nThere\u0026rsquo;s a few built-in functions available already:\n   Functions Description     Program.withConsoleTrace Print every message, model and exception received and/or generated by the init, update and view functions.",content:"In Fabulous, everything happens in a centralized message loop that is responsible for calling your init, update and view functions.\nFabulous allows you to plug into this loop to run custom logic such as logging and error handling.\nThere\u0026rsquo;s a few built-in functions available already:\n   Functions Description     Program.withConsoleTrace Print every message, model and exception received and/or generated by the init, update and view functions. Really useful while debugging. Might slow down the app a bit.   Program.withTrace (trace) Call custom tracing function everytime Fabulous needs to update the app. Signature: trace: 'msg -\u0026gt; 'model -\u0026gt; unit   Program.withErrorHandler (onError) Call custom error handling logic. Signature: onError: string * exn -\u0026gt; unit    To use them, you will need to add them when declaring the runner, before calling XamarinFormsProgram.run.\nYou can add multiple trace functions, one after another.\ntype App () as app = inherit Application () let runner = Program.mkProgram App.init App.update App.view |\u0026gt; Program.withConsoleTrace |\u0026gt; Program.withErrorHandler (fun (message, exn) -\u0026gt; writeToDisk exn) |\u0026gt; XamarinFormsProgram.run app  In this example, logs will be written to the console before the error handler can write the exceptions to the disk.\nWriting a custom trace function # Writing a custom trace function is simple.\nYou need to make a function that accepts a Program\u0026lt;'model, 'msg, 'view\u0026gt; and that outputs another Program\u0026lt;'model, 'msg, 'view\u0026gt;.\nThis Program defines the handlers that are responsibles for calling init, update and views as well as handle errors. You can define your own handlers instead to do additional logic.\nMake sure to call the previous Program handlers in your owns, otherwise you will completely bypass Fabulous.\nHere\u0026rsquo;s a simple example that prints a message each time something happens\nlet withSimpleTrace (program: Program\u0026lt;'model, 'msg, _\u0026gt;) = let traceInit () = Console.WriteLine \u0026quot;Init\u0026quot; program.init () let traceUpdate msg model = Console.WriteLine \u0026quot;Update\u0026quot; program.update msg model let traceView model dispatch = Console.WriteLine \u0026quot;View\u0026quot; program.update msg model let traceOnError (message, exn) = Console.WriteLine \u0026quot;Error\u0026quot; program.onError (message, exn) { program with init = traceInit update = traceUpdate view = traceView onError = traceOnError } type App () as app = inherit Application () let runner = Program.mkProgram App.init App.update App.view |\u0026gt; Program.withSimpleTrace |\u0026gt; XamarinFormsProgram.run app  You\u0026rsquo;re not required to implement all handlers, if you only need to override update then just override that one.\nlet withSimpleTrace (program: Program\u0026lt;'model, 'msg, _\u0026gt;) = let traceUpdate msg model = Console.WriteLine \u0026quot;Update\u0026quot; program.update msg model { program with update = traceUpdate }  AppCenter # Here\u0026rsquo;s a good example of implementing our own trace function.\nVisual Studio App Center is a DevOps portal tailored for mobile application development.\nIt handles everything from build, tests, distribution, analytics and crashes reporting, for Android, iOS and UWP.\nWe can define our own trace functions to send analytics and crashes to AppCenter.\nAppCenter provides us with a really simple way to report to it.\nWe only need to install the following packages:\n Microsoft.AppCenter.Analytics Microsoft.AppCenter.Crashes  Once the packages added, we can access 3 methods:\n Start: Initialize AppCenter by providing our app secrets Analytics.TrackEvent: Track a custom event with associated data Crashes.TrackError: Track an exception.  AppCenter will provide a dashboard of those events and exceptions along with stack traces\nHere we override update to call Analytics.TrackEvent, and onError to call Crashes.TrackError.\nmodule AppCenter = type AppCenterUpdateTracer\u0026lt;'msg, 'model\u0026gt; = 'msg -\u0026gt; 'model -\u0026gt; (string * (string * string) list) option /// Trace all the updates to AppCenter let withAppCenterTrace (shouldTraceUpdate: AppCenterUpdateTracer\u0026lt;_, _\u0026gt;) (program: Program\u0026lt;_, _, _\u0026gt;) = let traceUpdate msg model = match shouldTraceUpdate msg model with | Some (key, value) -\u0026gt; Analytics.TrackEvent (key, dict value) | None -\u0026gt; () program.update msg model let traceError (message, exn) = Crashes.TrackError(exn, dict [ (\u0026quot;Message\u0026quot;, message) ]) { program with update = traceUpdate onError = traceError }  We could trace everything, but you should consider to trace the minimum to protect your users' privacy.\nTo do that, we have added a AppCenterUpdateTracer function that will filter the messages that interest us and what data we should extract from it.\nmodule Tracing = let hasValue = (not \u0026lt;\u0026lt; String.IsNullOrEmpty) \u0026gt;\u0026gt; string let rules msg _ = match msg with | App.Msg.GoToAbout -\u0026gt; Some (\u0026quot;Navigation\u0026quot;, [ (\u0026quot;Page\u0026quot;, \u0026quot;About\u0026quot;) ]) | App.Msg.NavigationPopped -\u0026gt; Some (\u0026quot;Back Navigation\u0026quot;, []) | App.Msg.UpdateWhenContactAdded c -\u0026gt; Some (\u0026quot;Contact added\u0026quot;, [ (\u0026quot;Has Email\u0026quot;, hasValue c.Email) (\u0026quot;Has Phone\u0026quot;, hasValue c.Phone) (\u0026quot;Has Address\u0026quot;, hasValue c.Address) ]) | _ -\u0026gt; None  In our App class, we need to call AppCenter.Start(\u0026quot;appsecrets\u0026quot;, typeof\u0026lt;Analytics\u0026gt;, typeof\u0026lt;Crashes\u0026gt;) to initialize it.\ntype App () as app = inherit Application () do AppCenter.Start(\u0026quot;ios=(...);android=(...)\u0026quot;, typeof\u0026lt;Analytics\u0026gt;, typeof\u0026lt;Crashes\u0026gt;) let runner = Program.mkProgram App.init App.update App.view |\u0026gt; AppCenter.withAppCenterTrace Tracing.rules |\u0026gt; XamarinFormsProgram.run app  "}).add({id:76,href:"https://fsprojects.github.io/Fabulous/docs/v1/tutorials/dev-tools/",title:"Using the Fabulous command line",description:"With the fabulous-cli you can run LiveUpdate.\nInstall fabulous-cli:\n// install latest dotnet tool install -g fabulous-cli // install explicit version dotnet tool install -g fabulous-cli --version {versionnumber}  Update fabulous-cli:\ndotnet tool update -g fabulous-cli  Uninstall fabulous-cli:\ndotnet tool uninstall -g fabulous-cli  Live Update # There is an experimental LiveUpdate mechanism available. The aim of this is primarily to enable modifying the view function in order to see the effect of adjusting of visual options.",content:"With the fabulous-cli you can run LiveUpdate.\nInstall fabulous-cli:\n// install latest dotnet tool install -g fabulous-cli // install explicit version dotnet tool install -g fabulous-cli --version {versionnumber}  Update fabulous-cli:\ndotnet tool update -g fabulous-cli  Uninstall fabulous-cli:\ndotnet tool uninstall -g fabulous-cli  Live Update # There is an experimental LiveUpdate mechanism available. The aim of this is primarily to enable modifying the view function in order to see the effect of adjusting of visual options.\nAt the time of writing this has been trialled with:\n Visual Studio + Android (USB Device or Emulator) Visual Studio for Mac + Android (USB Device or Emulator) Visual Studio for Mac + iOS (USB Device or Emulator) Visual Studio + WPF  Some manual set-up is required.\n Install or update fabulous-cli as a global tool  dotnet tool install -g fabulous-cli dotnet tool update -g fabulous-cli    Install or update the NuGet package Fabulous.XamarinForms.LiveUpdate for all projects in your app.\nThis is the default for apps created with templates 0.13.10 and higher. Do a clean build.\n  Add the following reference to enable live update:\n  open Fabulous.XamarinForms.LiveUpdate   Uncomment or add the code in the #if section below:  type App () = inherit Application() .... #if DEBUG do runner.EnableLiveUpdate () #endif   If running on Android, forward requests from localhost to the Android Debug Bridge:  USB:\nadb -d forward tcp:9867 tcp:9867  EMULATOR:\nadb -e forward tcp:9867 tcp:9867    Launch your app in Debug mode (note: you can use Release mode but must set Linking options to None rather than SDK Assemblies)\n  Run the following from your core project directory (e.g. SqueakyApp\\SqueakyApp)\n  cd SqueakyApp\\SqueakyApp fabulous --watch --send   It may be necessary to launch Visual Studio with elevated permissions (\u0026ldquo;Run as administrator\u0026rdquo;); otherwise, runner.EnableLiveUpdate() may fail to start the HttpListener, which will cause LiveUpdate to fail.  Now, whenever you save a file in your core project directory, the fabulous watcher will attempt to recompile your changed file and send a representation of its contents to your app via a PUT request to the given webhook. The app then deserializes this representation and adds the declarations to an F# interpreter. This interpreter will make some reflective calls into the existing libraries on device.\nTo take effect as app changes, your code must have a single declaration in some module called programLiveUpdate or program taking no arguments.\nFor example:\nmodule App = ... let init() = ... let update model msg = ... let view model dispatch = ... let program = Program.mkProgram init update view  If a declaration like this is found the program object replaces the currently running Elmish program and the view is updated. The model state of the app is re-initialized.\nKnown limitations #   The F# interpreter used on-device has incompletenesses and behavioural differences:\n Object expressions may not be interpreted Implementations of ToString() and other overrides will be ignored Some other F# constructs are not supported (e.g. address-of operations, new delegate) Some overloading of methods by type is not supported (overloading by argument count is ok)  You can move generally move problematic constructs to a utility library, which will then be executed as compiled code.\n  Changes to the resources in a project (e.g. images) require a rebuild\n  Changes to Android and iOS projects require a rebuild\n  You can\u0026rsquo;t debug interpreted code from the IDE using breakpoints, stack inspection etc. Restart for that.\n  You may need to mock any platform-specific helpers you pass through, e.g.\n  module App = ... let init() = ... let update (helper1, helper2) model msg = ... let view model dispatch = ... #if DEBUG // The fake program, used when LiveUpdate is activated and a program change has been made module AppLiveUpdate = open App let mockHelper1 () = ... let mockHelper2 () = ... let programLiveUpdate = Program.mkProgram init (update (mockHelper1, mockHelper2)) view #endif type App (helper1, helper2) = inherit Application() .... // The real program, used when LiveUpdate is not activated or a program change has not been made let program = Program.mkProgram App.init (App.update (helper1, helper2)) App.view    There may be issues running on networks with network policy restrictions\n  In Visual Studio 2019, by default you cannot edit files whilst debugging. To enable file edits, turn OFF Edit and Continue by going to Tools-\u0026gt;Options, selecting Debug-\u0026gt;General and unchecking Enable Edit and Continue.\n  Troubleshooting # The LiveUpdate mechanism is very experimental.\n Debug output is printed to console by fabulous Debug output is printed to app-output by the on-device web server  ERROR SENDING TO WEBHOOK: \u0026quot;System.Net.WebException: No connection could be made because the target machine actively refused it.\u0026quot;\nIf the LiveUpdate console displays this error there are multiple possilbe causes:\n Visual Studio needs elevated permissions to execute \u0026ldquo;EnableLiveUpdate()\u0026rdquo;.  Solution: launch Visual Studio using the \u0026ldquo;Run as Administrator\u0026rdquo; option   Connection to wrong webhook ip.  Solution: check the output window in Visual Studio and explicitly specify the webhook url:    Local firewall on Mac blocks connection.  Solution: add a firewall exception for tcp port 9867   Firewall blocks traffic (if Windows PC and Mac/iPhone are on different networks).  Solution: add a firewall exception for tcp port 9867    Quacked: \u0026quot;couldn't quack! the evaluation of the declarations in the code package failed: System.IO.FileNotFoundException: Could not load the file 'netstandard'...\u0026quot;\nIf the console displays this error then check your iOS Build settings and set the option Linker Behaviour to Don't Link:\n\nDesign # The fabulous watcher does this:\n  Cracks project options, listens for changes, then uses FSharp.Compiler.Service to compile\n  converts code output to PortaCode code model\n  serializes PortaCode using Newtonsoft.Json\n  sends to device by http.\n  Device app does this:\n  starts httplistener, which gets http request\n  deserializes PortaCode\n  uses Interpreter.fs to run.\n  looks for a \u0026ldquo;program\u0026rdquo; declaration in interpreted code and hacks into the currently running Elmish app and replaces the Fabulous \u0026ldquo;program\u0026rdquo; ie view/update/init logic.\n  Device app continues to use whatever library dlls are on device via reflection.\nPlease contribute documentation, updates and fixes to make the experience simpler.\n"}).add({id:77,href:"https://fsprojects.github.io/Fabulous/docs/v1/",title:"Version 1",description:"Fabulous v1",content:""}).add({id:78,href:"https://fsprojects.github.io/Fabulous/docs/v2/",title:"Version 2",description:"Fabulous v2",content:""}).add({id:79,href:"https://fsprojects.github.io/Fabulous/docs/v1/extensions/videomanager/",title:"VideoManager",description:"The MediaManager plugin allow to play audio and video with Xamarin. Using this VideoManager, you can create a dedicated view to render a video in your fabulous application.\nMediaManager has been created by Martijn van Dijk and its original project can be found on its github repository.\nThe nuget Fabulous.XamarinForms.VideoManager implements a view component for the type VideoView.\n   To use Fabulous.XamarinForms.VideoView, you must\n Add a reference to Plugin.",content:"The MediaManager plugin allow to play audio and video with Xamarin. Using this VideoManager, you can create a dedicated view to render a video in your fabulous application.\nMediaManager has been created by Martijn van Dijk and its original project can be found on its github repository.\nThe nuget Fabulous.XamarinForms.VideoManager implements a view component for the type VideoView.\n   To use Fabulous.XamarinForms.VideoView, you must\n Add a reference to Plugin.MediaManager and Plugin.MediaManager.Forms across your whole solution. This will add appropriate references to your platform-specific Android and iOS projects too. Next add a reference to Fabulous.XamarinForms.VideoManager across your whole solution.  After these steps you can use VideoView in your view function. Here is a simple example of using VideoView to display a video player of Big Buck Bunny:\nopen Fabulous.XamarinForms View.VideoView( source = \u0026quot;https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\u0026quot;, showControls = false, heightRequest = 500., widthRequest = 200.)  See also:\n Interface Objects. Using MediaManager for Xamarin. Source for the VideoManager extension Source for the Xamarin MediaManager Defining Extensions  "}).add({id:80,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/performance/",title:"View and performance",description:"The performance of your app may in some cases be dominated by your view function.\nThis is particularly the case if many message updates are being generated and processed, though not if other operations dominate such as network latency. Improving the performance of your view function should be done with respect to your overall performance targets and needs.\nOn each update to the model, the view function is executed. The resulting view is then compared item by item with the previous view and updates are made to the underlying controls.",content:"The performance of your app may in some cases be dominated by your view function.\nThis is particularly the case if many message updates are being generated and processed, though not if other operations dominate such as network latency. Improving the performance of your view function should be done with respect to your overall performance targets and needs.\nOn each update to the model, the view function is executed. The resulting view is then compared item by item with the previous view and updates are made to the underlying controls.\nAs a result, views functions that are frequently executed (because of many message updates) are generally only efficient for large UIs if the unchanging parts of a UI are \u0026ldquo;memoized\u0026rdquo;, returning identical objects on each invocation of the view function.\nThis must be done explicitly. One way of doing this is to use dependsOn. Here is an example for a 6x6 Grid that depends on nothing, i.e. never changes:\nlet view model dispatch = ... dependsOn () (fun model () -\u0026gt; View.StackLayout([ View.Label(\u0026quot;Grid (6x6, auto):\u0026quot;) View.Grid( rowdefs = [for i in 1 .. 6 -\u0026gt; box \u0026quot;auto\u0026quot;], coldefs = [for i in 1 .. 6 -\u0026gt; box \u0026quot;auto\u0026quot;], children = [ for i in 1 .. 6 do for j in 1 .. 6 do View.BoxView( Color((1.0/float i), (1.0/float j), (1.0/float (i+j)), 1.0) ) .GridRow(i-1) .GridColumn(j-1) ] ) ] )  Inside the function - the one passed to dependsOn - the model is rebound to be inaccessbile with a DoNotUseMe type so you can\u0026rsquo;t use it. Here is an example where some of the model is extracted:\nlet view model dispatch = ... dependsOn (model.CountForSlider, model.StepForSlider) (fun model (count, step) -\u0026gt; View.Slider(minimum=0.0, maximum=10.0, value= double step, valueChanged=(fun args -\u0026gt; dispatch (SliderValueChanged (int (args.NewValue + 0.5)))))) ...  In the example, we extract properties CountForSlider and StepForSlider from the model, and bind them to count and step. If either of these change, the section of the view will be recomputed and no adjustments will be made to the UI. If not, this section of the view will be reused. This helps ensure that this part of the view description only depends on the parts of the model extracted.\nYou can also use\n the fix function for portions of a view that have no dependencies at all (besides the \u0026ldquo;dispatch\u0026rdquo; function) the fixf function for command callbacks that have no dependencies at all (besides the \u0026ldquo;dispatch\u0026rdquo; function)  Optimizing view performance in advanced scenarios: the key property # Each time the view function is called, Fabulous will try to update the UI the most efficiently possible by reusing existing controls as much as possible (for exact details, see Views: Differential Update of Lists of Things).\nThis is fine in the majority of scenarios, but some times Fabulous might reuse controls that don\u0026rsquo;t really match the expectations we can have from the code.\nThis is especially true if the ordering of the elements are changed, or an element has been added/removed before other elements.\nThis can result in unnecessary creation of controls (lower performance) or losing state of a control (like a video playing).\nThis is because Fabulous doesn\u0026rsquo;t know about the intent of your code, and will try to reuse controls from first to last in the list.\nSay we have the following code:\nView.StackLayout([ if model.ShowFirstVideo then yield View.MediaElement(source = MediaPath \u0026quot;path/to/video.mp4\u0026quot;) yield View.MediaElement(source = MediaPath \u0026quot;path/to/other-video.mp4\u0026quot;) yield View.Button(text = \u0026quot;Toggle first video\u0026quot;, command = (fun () -\u0026gt; dispatch ToggleFirstVideo)) ])  In this case, when ShowFirstVideo = true, the StackLayout will have 3 children, the 1st and 2nd video players + the button.\nWhen ShowFirstVideo = false, there will be only 2 child left, the 2nd video player and the button.\nDue to how Fabulous reuses controls between updates, when switching ShowFirstVideo from false to true, Fabulous will remove the 2nd video player and reuse/update the 1st video player, which will lose the state of the 2nd video if it was playing.\nThat\u0026rsquo;s because Fabulous has no way of knowing the real intent behind your code. For it, all MediaElements are interchangeable.\nTo prevent that, the first thing you can do is to change ordering as little as possible.\nIf you really must change ordering, you can help Fabulous by providing a key value to let Fabulous know that a specific element should reuse the same control as previously.\nIn our example, this would be:\nView.StackLayout([ if model.ShowFirstVideo then yield View.MediaElement(source = MediaPath \u0026quot;path/to/video.mp4\u0026quot;) yield View.MediaElement(key = \u0026quot;second-player\u0026quot;, source = MediaPath \u0026quot;path/to/other-video.mp4\u0026quot;) yield View.Button(text = \u0026quot;Toggle first video\u0026quot;, command = (fun () -\u0026gt; dispatch ToggleFirstVideo)) ])  Now, Fabulous will be aware that second-player should remain the same between updates and that the first MediaElement should be added/removed given the value of ShowFirstVideo.\nkey must be unique among its sibling inside a collection (e.g. items, children).\nUsing the same key at different places is ok.\nViews: Differential Update of Lists of Things # There are a few different kinds of list in view descriptions:\n lists of raw data (e.g. data for a chart control, though there are no samples like that yet in this library) long lists of UI elements that are used to produce cells (e.g. ListView, see above) short lists of UI elements (e.g. StackLayout children) short lists of pages (e.g. NavigationPages pages)  The perf of incremental update to these is progressively less important as you go down that list above.\nFor all of the above, the typical, naive implementation of the view function returns a new list instance on each invocation. The incremental update of dynamic views maintains a corresponding mutable target (e.g. the Children property of a Xamarin.Forms.StackLayout, or an ObservableCollection to use as an ItemsSource to a ListView) based on the previous (PREV) list and the new (NEW) list.\nFabulous prioritizes reuse in the following order:\n Same ViewElement instance (when using dependsOn)  View.Grid([ dependsOn () (fun _ _ -\u0026gt; View.Label(text = \u0026quot;Hello, World!\u0026quot;)) ])   Same key and control type (aka. canReuseView returns true)  // Previous View View.Grid([ View.Label(key = \u0026quot;header\u0026quot;, text = \u0026quot;Previous Header\u0026quot;) View.Label(key = \u0026quot;body\u0026quot;, text = \u0026quot;Previous body\u0026quot;) ]) // New View View.Grid([ View.Label(key = \u0026quot;header\u0026quot;, text = \u0026quot;New Header\u0026quot;) // Will reuse previous header View.Button(key = \u0026quot;body\u0026quot;, text = \u0026quot;New body\u0026quot;) // Won't be able to reuse previous body since Label != Button ])    If none of the above, Fabulous will select the first element that returns canReuseView = true among the eligible remaining previous elements.\n  If no previous element can be reused, a new one is created\n  Note that old keyed elements that didn\u0026rsquo;t had a matching key in the new list will be destroyed instead of being reused by new unkeyed elements to help developers avoid undesired animations, such as fade-in/fade-out on Button Text changes on iOS (#308) or ripple effects on Android Button.\nIn the end, controls that weren\u0026rsquo;t reused are destroyed.\nThis means\n  Incremental update costs minimally one transition of the whole list.\n  Incremental update recycles controls as much as possible if you use the same instance or key property.\nOtherwise, there is no guarantee that you get same control next time.\n  NOTE: The list diffing will limit mutations to only Move, Remove, and Insert, even when more straightforward operations could be done. This is to support the limitations imposed by how Xamarin.Forms reacts to changes in System.Collections.ObjectModel.ObservableCollection\u0026lt;'T\u0026gt;.\nThe above is sufficient for many purposes, but care must always be taken with large lists and data sources, see ListView above for example. Care must also be taken whenever data updates very rapidly.\n"}).add({id:81,href:"https://fsprojects.github.io/Fabulous/docs/v1/tutorials/view/",title:"Views",description:"The view function is a function returning your view elements based on the current model. For example:\nlet view model dispatch = View.ContentPage( title=\u0026quot;Pocket Piggy Bank\u0026quot;, content=View.Label(text = sprintf \u0026quot;Hello world!\u0026quot;) )  The view function is normal F# code that returns elements created using the View.* method calls.\nView functions are particularly useful when the existence, characteristics and layout of the view depends on information in the model. Differential update is used to efficiently update the Xamarin.",content:"The view function is a function returning your view elements based on the current model. For example:\nlet view model dispatch = View.ContentPage( title=\u0026quot;Pocket Piggy Bank\u0026quot;, content=View.Label(text = sprintf \u0026quot;Hello world!\u0026quot;) )  The view function is normal F# code that returns elements created using the View.* method calls.\nView functions are particularly useful when the existence, characteristics and layout of the view depends on information in the model. Differential update is used to efficiently update the Xamarin.Forms display based on the previous and current view descriptions.\nHere is a larger example:\ntype Model = { Balance : decimal CurrencySymbol : string User: string option } type Msg = | Spend of decimal | Add of decimal | Login of string option let init() = { Balance = 2m CurrencySymbol = \u0026quot;$\u0026quot; User = Some \u0026quot;user\u0026quot; }, Cmd.none let update msg model = match msg with | Spend x -\u0026gt; { model with Balance = model.Balance - x }, Cmd.none | Add x -\u0026gt; { model with Balance = model.Balance + x }, Cmd.none | Login user -\u0026gt; { model with User = user }, Cmd.none let view model dispatch = View.ContentPage( title=\u0026quot;Pocket Piggy Bank\u0026quot;, content=View.StackLayout(padding= Thickness 20.0, horizontalOptions=LayoutOptions.Center, verticalOptions=LayoutOptions.CenterAndExpand, children = [ match model.User with | Some user -\u0026gt; yield View.Label(text=sprintf \u0026quot;Logged in as : %s\u0026quot; user) yield View.Label(text=sprintf \u0026quot;Balance: %s%.2f\u0026quot; model.CurrencySymbol model.Balance) yield View.Button(text=\u0026quot;Withdraw\u0026quot;, command=(fun () -\u0026gt; dispatch (Spend 10.0m)), commandCanExecute=(model.Balance \u0026gt; 0.0m)) yield View.Button(text=\u0026quot;Deposit\u0026quot;, command=(fun () -\u0026gt; dispatch (Add 10.0m))) yield View.Button(text=\u0026quot;Logout\u0026quot;, command=(fun () -\u0026gt; dispatch (Login None))) | None -\u0026gt; yield View.Button(text=\u0026quot;Login\u0026quot;, command=(fun () -\u0026gt; dispatch (Login (Some \u0026quot;user\u0026quot;)))) ]))  The four main control groups used to create the user interface of a Xamarin.Forms application are:\n Pages Layouts Interface objects Cells  See also:\n Views and Performance Styling  "}).add({id:82,href:"https://fsprojects.github.io/Fabulous/docs/v1/api/controls/webview/",title:"WebView",description:"Basic example # View.ContentPage( backgroundColor = style.PageColor, title =\u0026quot;WebView\u0026quot;, content = View.WebView( source = UrlWebViewSource.op_Implicit \u0026quot;https://fsprojects.github.io/Fabulous/Fabulous.XamarinForms/\u0026quot; ) )  Basic example with styling # View.ContentPage( backgroundColor = style.PageColor, title = \u0026quot;WebView\u0026quot;, content = View.WebView( backgroundColor = style.ViewColor, margin = style.Thickness, source = UrlWebViewSource.op_Implicit \u0026quot;https://fsprojects.github.io/Fabulous/Fabulous.XamarinForms/\u0026quot; ) )  See also:\n WebView in Xamarin Forms Xamarin.Forms.WebView  More examples # WebView is a view for displaying web and HTML content in your app:",content:"Basic example # View.ContentPage( backgroundColor = style.PageColor, title =\u0026quot;WebView\u0026quot;, content = View.WebView( source = UrlWebViewSource.op_Implicit \u0026quot;https://fsprojects.github.io/Fabulous/Fabulous.XamarinForms/\u0026quot; ) )  Basic example with styling # View.ContentPage( backgroundColor = style.PageColor, title = \u0026quot;WebView\u0026quot;, content = View.WebView( backgroundColor = style.ViewColor, margin = style.Thickness, source = UrlWebViewSource.op_Implicit \u0026quot;https://fsprojects.github.io/Fabulous/Fabulous.XamarinForms/\u0026quot; ) )  See also:\n WebView in Xamarin Forms Xamarin.Forms.WebView  More examples # WebView is a view for displaying web and HTML content in your app:\nlet fabulousSite = \u0026quot;https://fsprojects.github.io/Fabulous/Fabulous.XamarinForms/\u0026quot; View.WebView( source = UrlWebViewSource.op_Implicit fabulousSite, backgroundColor = Color.Red, margin = Thickness(20.) )  "}).add({id:83,href:"https://fsprojects.github.io/Fabulous/docs/v1/extensions/xamarinforms-maps/",title:"Xamarin.Forms.Maps",description:"The nuget Fabulous.XamarinForms.Maps implements an extension for the types Map and Pin.\n  \nTo use Fabulous.XamarinForms.Maps, you must\n Add a reference to Fabulous.XamarinForms.Maps across your whole solution. Additionally follow the instructions to initialize Xamarin.Forms Maps. For example, on Android you must enable Google Play servies, add a call to Xamarin.FormsMaps.Init(this, bundle) to MainActivity.fs and add both and API key and uses-permission to AndroidManifest.xml.  After these steps you can use maps in your view function as follows:",content:"The nuget Fabulous.XamarinForms.Maps implements an extension for the types Map and Pin.\n  \nTo use Fabulous.XamarinForms.Maps, you must\n Add a reference to Fabulous.XamarinForms.Maps across your whole solution. Additionally follow the instructions to initialize Xamarin.Forms Maps. For example, on Android you must enable Google Play servies, add a call to Xamarin.FormsMaps.Init(this, bundle) to MainActivity.fs and add both and API key and uses-permission to AndroidManifest.xml.  After these steps you can use maps in your view function as follows:\nopen Xamarin.Forms.Maps open Fabulous.XamarinForms View.Map(hasZoomEnabled = true, hasScrollEnabled = true)  Next, a map with requested region around Timbuktu:\nlet timbuktu = Position(16.7666, -3.0026) View.Map(hasZoomEnabled = true, hasScrollEnabled = true, requestedRegion = MapSpan.FromCenterAndRadius(timbuktu, Distance.FromKilometers(1.0)))  Next, a map with two pins for Paris and London:\nlet paris = Position(48.8566, 2.3522) let london = Position(51.5074, -0.1278) let calais = Position(50.9513, 1.8587) View.Map(hasZoomEnabled = true, hasScrollEnabled = true, pins = [ View.Pin(paris, label=\u0026quot;Paris\u0026quot;, pinType = PinType.Place) View.Pin(london, label=\u0026quot;London\u0026quot;, pinType = PinType.Place) ], requestedRegion = MapSpan.FromCenterAndRadius(calais, Distance.FromKilometers(300.0)))  See also:\n Interface Objects. Working with Maps. Source for the Maps extension Defining Extensions  "}).add({id:84,href:"https://fsprojects.github.io/Fabulous/docs/v2/api/controls/element/",title:"Element",description:"Inheritance: None\nXamarin.Forms documentation: Element API\nConstructors # This control can\u0026rsquo;t be instantiated on its own. Its properties and events are inherited by its descendants.\nProperties #    Properties Description     automationId(value: string) Sets the automation identifier of the widget    Events #    Events Description     onMounted(value: \u0026lsquo;msg) Listens for the widget being mounted   onUnmounted(value: \u0026lsquo;msg) Listens for the widget being unmounted    ",content:"Inheritance: None\nXamarin.Forms documentation: Element API\nConstructors # This control can\u0026rsquo;t be instantiated on its own. Its properties and events are inherited by its descendants.\nProperties #    Properties Description     automationId(value: string) Sets the automation identifier of the widget    Events #    Events Description     onMounted(value: \u0026lsquo;msg) Listens for the widget being mounted   onUnmounted(value: \u0026lsquo;msg) Listens for the widget being unmounted    "}).add({id:85,href:"https://fsprojects.github.io/Fabulous/docs/v2/api/controls/label/",title:"Label",description:"Inheritance: Element -\u0026gt; NavigableElement -\u0026gt; VisualElement -\u0026gt; View\nXamarin.Forms documentation: Label API / Guide\nFor details on how the control actually works, please refer to the Xamarin.Forms documentation.\nConstructors #    Constructors Description     Label(text: string) Defines a Label widget with a text    Properties #    Properties Description     characterSpacing(value: float) Sets the spacing between each character of the text   font(?",content:"Inheritance: Element -\u0026gt; NavigableElement -\u0026gt; VisualElement -\u0026gt; View\nXamarin.Forms documentation: Label API / Guide\nFor details on how the control actually works, please refer to the Xamarin.Forms documentation.\nConstructors #    Constructors Description     Label(text: string) Defines a Label widget with a text    Properties #    Properties Description     characterSpacing(value: float) Sets the spacing between each character of the text   font(?size: float, ?namedSize: NamedSize, ?attributes: FontAttributes, ?fontFamily: string) Sets the font family used   horizontalTextAlignment(value: textAlignment) Sets the horizontal alignment of the text   lineBreakMode(value: LineBreakMode) Sets the line break mode   lineHeight(value: float) Sets the multiplier to apply to the default line height when displaying text   maxLines(value: int) Sets the maximum number of lines allowed   padding(value: Thickness) Sets the amount of padding around the text   padding(value: float) Sets a uniform amount of padding around the text   padding(left: float, top: float, right: float, bottom: float) Sets the amount of padding around the text   textColor(light: Color, ?dark: Color) Sets the text color depending if light or dark mode   textDecoration(value: TextDecorations) Sets the text decorations (underline, strike, etc) to apply on the text   textTransform(value: TextTransform) Sets the text transformation (lowercase, uppercase) to apply on the text   textType(value: TextType) Sets the text type (plain text, HTML)   verticalTextAlignment(value: TextAlignment) Sets the vertical alignment of the text   reference(value: ViewRef\u0026lt;Label\u0026gt;) Sets a ViewRef instance to retrieve the Xamarin.Forms.Label instance associated to this widget    Shorthand properties #    Properties Description     centerTextHorizontal() Center the text horizontally inside the Label. Same as horizontalTextAlignment(TextAlignment.Center)   centerTextVertical() Center the text vertically inside the Label. Same as verticalTextAlignment(TextAlignment.Center)    Events # None\nUsages # Label(\u0026quot;Hello World\u0026quot;) .characterSpacing(1.) .font(namedSize = NamedSize.Large, fontFamily = \u0026quot;Arial\u0026quot;, attributes = FontAttributes.Bold) .horizontalTextAlignment(TextAlignment.Center) .lineBreakMode(LineBreakMode.WordWrap) .lineHeight(1.5) .maxLines(1) .padding(10.) .textColor(light = Color.Red, dark = Color.Blue) .textDecoration(TextDecorations.Underline) .textTransform(TextTransform.Lowercase) .textType(TextType.Text) .verticalTextAlignment(TextAlignment.Center)  Use shorthand properties # Label(\u0026quot;Hello World\u0026quot;) .size(500., 500.) .centerTextHorizontal() .centerTextVertical()  Get access to the underlying Xamarin.Forms.Label # let labelRef = ViewRef\u0026lt;Label\u0026gt;() Label(\u0026quot;Hello World\u0026quot;) .reference(labelRef)  "}).add({id:86,href:"https://fsprojects.github.io/Fabulous/docs/v2/api/controls/navigableelement/",title:"NavigableElement",description:"Inheritance: Element\nXamarin.Forms documentation: NavigableElement API\nConstructors # This control can\u0026rsquo;t be instantiated on its own. Its properties and events are inherited by its descendants.\nProperties # TBD\nEvents # TBD",content:"Inheritance: Element\nXamarin.Forms documentation: NavigableElement API\nConstructors # This control can\u0026rsquo;t be instantiated on its own. Its properties and events are inherited by its descendants.\nProperties # TBD\nEvents # TBD\n"}).add({id:87,href:"https://fsprojects.github.io/Fabulous/docs/v2/api/controls/view/",title:"View",description:"Inheritance: Element -\u0026gt; NavigableElement -\u0026gt; VisualElement\nXamarin.Forms documentation: View API\nConstructors # This control can\u0026rsquo;t be instantiated on its own. Its properties and events are inherited by its descendants.\nProperties # TBD\nEvents # TBD",content:"Inheritance: Element -\u0026gt; NavigableElement -\u0026gt; VisualElement\nXamarin.Forms documentation: View API\nConstructors # This control can\u0026rsquo;t be instantiated on its own. Its properties and events are inherited by its descendants.\nProperties # TBD\nEvents # TBD\n"}).add({id:88,href:"https://fsprojects.github.io/Fabulous/docs/v2/api/controls/visualelement/",title:"VisualElement",description:"Inheritance: Element -\u0026gt; NavigableElement\nXamarin.Forms documentation: VisualElement API\nConstructors # This control can\u0026rsquo;t be instantiated on its own. Its properties and events are inherited by its descendants.\nProperties # TBD\nEvents # TBD",content:"Inheritance: Element -\u0026gt; NavigableElement\nXamarin.Forms documentation: VisualElement API\nConstructors # This control can\u0026rsquo;t be instantiated on its own. Its properties and events are inherited by its descendants.\nProperties # TBD\nEvents # TBD\n"}).add({id:89,href:"https://fsprojects.github.io/Fabulous/docs/",title:"Docs",description:"Docs",content:""}),search.addEventListener('input',b,!0);function b(){var b,e;const d=5;b=this.value,e=a.search(b,{limit:d,enrich:!0});const c=new Map;for(const a of e.flatMap(a=>a.result)){if(c.has(a.doc.href))continue;c.set(a.doc.href,a.doc)}if(suggestions.innerHTML="",suggestions.classList.remove('d-none'),c.size===0&&b){const a=document.createElement('div');a.innerHTML=`No results for "<strong>${b}</strong>"`,a.classList.add("suggestion__no-results"),suggestions.appendChild(a);return}for(const[h,g]of c){const b=document.createElement('div');suggestions.appendChild(b);const a=document.createElement('a');a.href=h,b.appendChild(a);const e=document.createElement('span');e.textContent=g.title,e.classList.add("suggestion__title"),a.appendChild(e);const f=document.createElement('span');if(f.textContent=g.description,f.classList.add("suggestion__description"),a.appendChild(f),suggestions.appendChild(b),suggestions.childElementCount==d)break}}})()