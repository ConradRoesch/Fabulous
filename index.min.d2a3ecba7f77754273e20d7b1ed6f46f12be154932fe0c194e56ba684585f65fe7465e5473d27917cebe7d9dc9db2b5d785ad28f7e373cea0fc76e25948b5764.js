var suggestions=document.getElementById('suggestions'),search=document.getElementById('search');search!==null&&document.addEventListener('keydown',inputFocus);function inputFocus(a){a.ctrlKey&&a.key==='/'&&(a.preventDefault(),search.focus()),a.key==='Escape'&&(search.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(c){const d=suggestions.classList.contains('d-none');if(d)return;const a=[...suggestions.querySelectorAll('a')];if(a.length===0)return;const b=a.indexOf(document.activeElement);if(c.key==="ArrowUp"){c.preventDefault();const d=b>0?b-1:0;a[d].focus()}else if(c.key==="ArrowDown"){c.preventDefault();const d=b+1<a.length?b+1:b;a[d].focus()}}(function(){var a=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});a.add({id:0,href:"/docs/architecture/goals-of-v2/",title:"Reasonable goals of v2",description:"Due to the complex nature of GUI framework development, Fabulous v2 represents a substantial amount of work.\nIn order to manage and optimize the time of everyone involved, more reasonable goals are required to get a version 2 out as fast as possible.\nDoing a complete redesign of the architecture + adding .NET 6 / MAUI support at the same time feels really discouraging.\nThat\u0026rsquo;s why this version 2 will be done in 4 separate releases:",content:"Due to the complex nature of GUI framework development, Fabulous v2 represents a substantial amount of work.\nIn order to manage and optimize the time of everyone involved, more reasonable goals are required to get a version 2 out as fast as possible.\nDoing a complete redesign of the architecture + adding .NET 6 / MAUI support at the same time feels really discouraging.\nThat\u0026rsquo;s why this version 2 will be done in 4 separate releases:\n Focus on performance and Xamarin.Forms 5.0 support Migration path from version 1 Components .NET 6 / MAUI support  Focus on performance and extensibility # While Fabulous v1 works perfectly well, it relies a lot on object allocations, does a lot of cache misses, etc.\nThe primary goal of v1 was not to get something optimized but to get something working.\nOver the years, it has become apparent we need to optimize for speed and memory usage.\nEspecially on Android where low-end devices can be found, frequent garbage collections are noticed and can freeze the app, sometimes for up to several seconds!\nAlso in addition to perf improvements, v2 will focus on making extensibility easier.\nTo improve that, here\u0026rsquo;s what will be done:\n Redesign of the internal architecture  Reduce garbage collection to a minimum on hot paths (heavy use of structs, optimize against cache misses, etc) Improve computation speed (micro-benchmarking on critical paths - benchmarking end-to-end on typical use cases)   Implement a generic Reconciler in Core  This will help us optimize allocations and speed It will also be useful for framework integration (like Fabulous.XF, Fabulous.MAUI, etc). They won\u0026rsquo;t need to worry about reconciliation.   Attribute level diff instead of control level diff  This change will make it easier to extend an existing control without having to rewrite the whole mapping each time. (eg. https://github.com/TimLariviere/FabulousContacts/blob/master/FabulousContacts/Controls/BorderedEntry.fs) Such extensibilty can be done via method extensions Ã  la SwiftUI   Decorrelate Update from View  This will be useful in cases where we receive numerous updates in a short timeframe or we received them continously (streams). The runner will still treat all the updates and update the model, but the view will be able to take only the latest available model if diffing is not keeping up with the updates. The update loop will be able to run on another thread since it won\u0026rsquo;t need to access the UI, resulting in faster updates.   Enable having multiple instances of Fabulous in the same app (no singleton)  Today, Fabulous is limited to only 1 Program running at the same time. This change will allow to have multiple programs in a same app - like for example 2 Fabulous controls in a C# XF app.   Add lifecycle to ViewElement (on mount, on dismount, on create, on destroy) Produce smallest binaries as possible  Make sure all unused types are trimmed away by the Android / iOS linkers    This version 2 will focus 100% on dynamic views (main selling point). Fabulous.StaticViews will be removed completely.\nSupport for Fabulous.AdaptiveViews won\u0026rsquo;t be considered.\nRelease target: December 2021 (include v2 architecture and XF 5.0 support)\nXamarin.Forms 5.0 support # So that we can validate and use the new architecture of Fabulous v2, a framework integration with XF 5.0 will be required.\nInitially, we wanted to test it with MAUI and only later on write a migration path from Fabulous v1 / XF 5.0 but the development experience with MAUI is still way too fragile as of November 2021.\nFor that reason, we believe it is better to start with Xamarin.Forms 5.0 support.\nHere\u0026rsquo;s what will be done:\n Design a new View DSL  Strongly-typed  Each control will return a typed element instead of just ViewElement This will prevent combining incompatible controls (eg. a Label inside a ListView) This will also prevent combining 2 UIs using incompatible messages   Better for autocompletion  Having uniquely-typed elements, IDEs will be able to show only available properties and events   Better defaults  Each control can have specialized constructors to enforce meaningful defaults (eg. Label will always have Text, Button will always have Text and an Action, etc.)   Easier to extend  Adding a new property to an element will be as simple as creating an extension method (https://github.com/TimLariviere/Fabulous-new/blob/618c8226533134cb73f7f79049d1fa737d2b83d6/src/Fabulous.Maui/Microsoft.Maui.Controls.fs#L363-L394)   No dispatch  Avoid accidentally keeping the dispatch function passed as argument when this one can be swapped with another dispatch at any moment by Fabulous     Update Fabulous.XamarinForms.Generator to generate the wrappers for the new DSL Port all the existing samples to v2 and the new DSL  This is an early example of the new DSL done with MAUI.\ntype Msg = | Increment | Decrement let view model = Application([ Window(\u0026quot;Main\u0026quot;, VerticalStackLayout([ Label($\u0026quot;Hello World from Fabulous: {model.Count}\u0026quot;) .font(Font.SystemFontOfSize(20.)) .horizontalLayoutAlignment(Primitives.LayoutAlignment.Fill) .verticalLayoutAlignment(Primitives.LayoutAlignment.Fill) .horizontalTextAlignment(TextAlignment.Center) .background(SolidPaint(Colors.Red)) Button(\u0026quot;Click me\u0026quot;, Increment) ]) .spacing(10.) .background(SolidPaint(Colors.Aqua)) ) ])  Release target: December 2021 (include v2 architecture and XF 5.0 support)\nMigration path from version 1 # When v2 and the new DSL will be validated by early adopters, we will need to work on a migration path for users that developped their apps with Fabulous v1.\nIdeally, there should be the least amount of breaking changes possible since it\u0026rsquo;s mostly internal stuffs that will change.\nTo permit this, here\u0026rsquo;s what we will be done:\n Make the old DSL work with v2  This will allow (ideally) seamless transition from v1 to v2   Make Fabulous.XamarinForms.Generator outputs both the new DSL and old DSL for Xamarin.Forms 5.0 Release everything related to the migration (old DSL) in a compatibility package instead of directly in Fabulous.XamarinForms  Release target: February 2022\nComponents # The concept of components was one of the inital motivators for making a version 2. The idea was to create smaller programs with their own MVU loop and runner, and then embed them in a ViewElement so they can be included in a larger program. This had the advantage to reduce the UI tree to process during diffing.\nTurns out it\u0026rsquo;s not that simple to implement.\n@twop recommended to take a similar approach than Elm: Actor Model. Instead of implementing the concept directly in the core of Fabulous with dedicated widgets, we can create an Actor Model library to facilitate communication between independent parts of the application.\nEach part is given a Process ID and they can send messages to each other using that id. This will still trigger a whole update from the root of the app, but with v2 architecture, diffing should be way more efficient than today so it shouldn\u0026rsquo;t be an issue to not have isolated components.\nInspiration: https://www.youtube.com/watch?v=YV_qrjN8bRA\nWe\u0026rsquo;re still discussing how to implement such a library.\nRelease target: April 2022\n.NET 6 / MAUI support # Finally when everything else will be done and .NET 6.0 / MAUI is in a stable state, we will be able to start working on support for MAUI in Fabulous.\nRelease target: Depends on the MAUI team. Earliest possible - May / June 2022\nWhat about all the other stuff? # Things like LiveUpdate, more advanced use case support, etc won\u0026rsquo;t be included as part of the official repository. At least not initially.\nAnyway, they will have to wait after we get version 2 fully released and production-ready before consideration.\n"}).add({id:1,href:"/docs/tutorials/using-nightly-builds/",title:"Using nightly builds",description:"On every commit to the main branch, packages for each project and template are automatically generated and published to the GitHub Packages Registry.\nIf you plan to use those packages, you\u0026rsquo;ll need to add a nuget.config file to your solution folder and you\u0026rsquo;ll need to add a source pointing to https://nuget.pkg.github.com/TimLariviere/index.json.\nYou\u0026rsquo;ll also new to generate a GitHub PAT (personal access token) for your account and set that token in the nuget.",content:"On every commit to the main branch, packages for each project and template are automatically generated and published to the GitHub Packages Registry.\nIf you plan to use those packages, you\u0026rsquo;ll need to add a nuget.config file to your solution folder and you\u0026rsquo;ll need to add a source pointing to https://nuget.pkg.github.com/TimLariviere/index.json.\nYou\u0026rsquo;ll also new to generate a GitHub PAT (personal access token) for your account and set that token in the nuget.config file.\nFor instructions on how to generate a GitHub PAT, see Authenticating with a Personal Access Token.\nExample of nuget.config:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;packageSources\u0026gt; \u0026lt;clear /\u0026gt; \u0026lt;add key=\u0026quot;nuget\u0026quot; value=\u0026quot;https://api.nuget.org/v3/index.json\u0026quot; /\u0026gt; \u0026lt;!-- For nightly builds --\u0026gt; \u0026lt;add key=\u0026quot;fabulous\u0026quot; value=\u0026quot;https://nuget.pkg.github.com/TimLariviere/index.json\u0026quot; /\u0026gt; \u0026lt;/packageSources\u0026gt; \u0026lt;packageSourceCredentials\u0026gt; \u0026lt;fabulous\u0026gt; \u0026lt;add key=\u0026quot;Username\u0026quot; value=\u0026quot;USERNAME\u0026quot; /\u0026gt; \u0026lt;add key=\u0026quot;ClearTextPassword\u0026quot; value=\u0026quot;TOKEN\u0026quot; /\u0026gt; \u0026lt;/fabulous\u0026gt; \u0026lt;/packageSourceCredentials\u0026gt; \u0026lt;/configuration\u0026gt;  Using nightly templates # It\u0026rsquo;s the same than above, except you\u0026rsquo;ll need to create nuget.config first so the dotnet CLI can retrieve the templates from GitHub.\nOnce you configured nuget.config, you can run\ndotnet new -i Fabulous.XamarinForms.Templates::XYZ  where XYZ is the latest version from Fabulous.XamarinForms.Templates versions.\n"}).add({id:2,href:"/docs/architecture/virtualized-collections/",title:"Virtualized collections",description:"Virtualized collection enables displaying a scrolling list of data while only instantiating the visible rows. When scrolling, the no longer visible rows are reused and updated with the new data.\nIn Xamarin.Forms, this is done via 2 controls: ListView and CollectionView. Also those controls support grouping data and displaying a group header/footer.\nMy main idea was to let the user pass in its data source and declare a template function (as well as 2 others for header/footer).",content:"Virtualized collection enables displaying a scrolling list of data while only instantiating the visible rows. When scrolling, the no longer visible rows are reused and updated with the new data.\nIn Xamarin.Forms, this is done via 2 controls: ListView and CollectionView. Also those controls support grouping data and displaying a group header/footer.\nMy main idea was to let the user pass in its data source and declare a template function (as well as 2 others for header/footer). Fabulous would just remap the data source (Seq.map templateFn items) and pass it to Xamarin.Forms, avoiding enumeration.\nUsages # let items = [ 1 .. 1000 ] ListView(items) (fun item -\u0026gt; TextCell($\u0026quot;{item}\u0026quot;)) CollectionView(items) (fun item -\u0026gt; Label($\u0026quot;{item}\u0026quot;))  // According to Xamarin.Forms documentation, when grouping, data source should be an IEnumerable of IEnumerable type Group(headerData: string, footerData: string, items: IEnumerable\u0026lt;int\u0026gt;) = inherit ObservableCollection\u0026lt;int\u0026gt;(items) member _.HeaderData = headerData member _.FooterData = footerData let groups = ObservableCollection\u0026lt;Group\u0026gt;( [ for i = 0 .. 100 do Group($\u0026quot;Header {i}\u0026quot;, $\u0026quot;Footer {i}\u0026quot;, [1 .. 100]) ] ) // ListView has no Footer for groups GroupedListView(groups) (fun group -\u0026gt; TextCell(group.HeaderData)) (fun item -\u0026gt; TextCell($\u0026quot;{item}\u0026quot;)) GroupedCollectionView(items) (fun group -\u0026gt; Label(group.HeaderData)) (fun item -\u0026gt; Label($\u0026quot;{item}\u0026quot;) (fun group -\u0026gt; Label(group.FooterData))  How ListView and CollectionView work in Xamarin.Forms # Virtualization in ListView/CollectionView works by combining 2 properties:\n ItemsSource: a list of raw data DataTemplate: a template object used to describe what the row should look like  Given the MVVM nature of XF, row reuse is mostly driven by bindings. DataTemplate doesn\u0026rsquo;t know about the raw data it will receive and only setups binding.\n\u0026lt;ListView ItemsSource=\u0026quot;{Binding Items}\u0026quot;\u0026gt; \u0026lt;ListView.ItemTemplate\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;TextCell Text=\u0026quot;{Binding MyProperty}\u0026quot; /\u0026gt; \u0026lt;DataTemplate\u0026gt; \u0026lt;/ListView.ItemTemplate\u0026gt; \u0026lt;/ListView\u0026gt;  Xamarin.Forms creates a row using the DataTemplate and sets its BindingContext with the raw item. This triggers refresh of the row UI. Same on row reuse, XF sets the new raw item into BindingContext and refreshes the bindings.\nThis model doesn\u0026rsquo;t work with Fabulous at all, due to the lack of Binding. Fortunately, we can work with DataTemplateSelector to access the current item before returning the appropriate DataTemplate. This allows Fabulous to support virtualization.\nHow it works in Fabulous # Semantically speaking, our Widget is very close to DataTemplate. They both describe what a specific piece of UI should look like. The main difference is that DataTemplate doesn\u0026rsquo;t know of the data it will work with in advance, whereas Widget has been built with that data.\nSo the main challenge was to make the 2 concepts compatible.\nSimple collections (aka not grouped) # Storing data and the template function # In Fabulous v1, we were creating all ViewElement items (Widget in v2) on each view update. This can be problematic in case you have a large number of items.\nActually thanks to how virtualization works, we only need to \u0026ldquo;process\u0026rdquo; a couple of items for the visible rows. No need to go create all widgets on each view update.\nTo support that, the following type has been created:\ntype WidgetItems\u0026lt;'T\u0026gt; = { // The raw list of data provided by the user OriginalItems: IEnumerable\u0026lt;'T\u0026gt; // Function to convert one item to a widget Template: 'T -\u0026gt; Widget }  This WidgetItems is created by the function ViewHelpers.buildItems and is stored directly in the ItemsSource scalar attribute.\nlet buildItems\u0026lt;'msg, 'marker, 'itemData, 'itemMarker\u0026gt; key attrDef (items: seq\u0026lt;'itemData\u0026gt;) (itemTemplate: 'itemData -\u0026gt; WidgetBuilder\u0026lt;'msg, 'itemMarker\u0026gt;) = (...) static member inline ListView\u0026lt;'msg, 'itemData, 'itemMarker when 'itemMarker :\u0026gt; ICell\u0026gt;(items: seq\u0026lt;'itemData\u0026gt;) = ViewHelpers.buildItems\u0026lt;'msg, IListView, 'itemData, 'itemMarker\u0026gt; ViewKeys.ListView ItemsViewOfCell.ItemsSource items  Note the use of 'itemMarker to enforce the type of widget items\nKeeping the original items allows us to directly compare them on each update to determine if we need to update the UI.\n(fun (a, b) -\u0026gt; ScalarAttributeComparers.equalityCompare(a.OriginalItems, b.OriginalItems))  Currently, scalar attributes in Fabulous have 2 generic parameters: the 'inputType and 'modelType.\nThe 'inputType is what we expect the users to provide us. The 'modelType is an optimized representation of the same data (eg. 'inputType is int list, 'modelType will be int[]).\nBefore storing the attribute value, we convert 'inputType to 'modelType through the Convert function declared in the ScalarAttributeDefinition; 'inputType is never stored.\nBut the comparison function shown just above is only done between 2 'modelTypes, but ListView/CollectionView expect an IEnumerable and not a WidgetItems.\nSo to support this, we need another generic parameter 'valueType and the corresponding ConvertValue: 'modelType -\u0026gt; 'valueType function.\ntype ScalarAttributeDefinition\u0026lt;'inputType, 'modelType, 'valueType\u0026gt; = { (...) Compare: 'modelType -\u0026gt; 'modelType ConvertValue: 'modelType -\u0026gt; 'valueType }  With this, we can still store and compare WidgetItems, but when we actually need to apply the value to the XF property, we call ConvertValue to transform it. Attributes that don\u0026rsquo;t need conversion can use the id function to make it transparent.\nFor WidgetItems, we build an IEnumerable on the fly using the original items and the template function before assigning it to the XF property ItemsSource.\n(fun modelValue -\u0026gt; seq { for x in modelValue.OriginalItems do modelValue.Template x })  Now Xamarin.Forms has a list of Widgets, and thanks to seq, it will only enumerate the items it needs to display.\nLoading Widgets into rows # Unlike DataTemplate in MVVM apps, instead of setting bindings to capture the raw data inside BindingContext, we now have a Widget.\nTo make it work, we need 2 things:\n A DataTemplateSelector that will know which DataTemplate to create based on the widget A DataTemplate that will listen to BindingContextChanged and run the Reconciler when a widget is attached to the row  // IsHeader is only for grouping type WidgetDataTemplateSelector internal (node: IViewNode, itemType: VirtualizedItemType) = inherit DataTemplateSelector() /// Reuse data template for already known widget target type let cache = Dictionary\u0026lt;Type, WidgetDataTemplate\u0026gt;() override _.OnSelectTemplate(item, _) = let widget = BindableHelpers.getWidgetFromBindingContext itemType item let widgetDefinition = WidgetDefinitionStore.get widget.Key let targetType = widgetDefinition.GetTargetType(widget) match cache.TryGetValue(targetType) with | true, dataTemplate -\u0026gt; dataTemplate | false, _ -\u0026gt; let dataTemplate = WidgetDataTemplate(targetType, isHeader, node) cache.Add(targetType, dataTemplate) dataTemplate  Note that like said earlier, DataTemplate are created before knowing which value they will host. This means we can only create an empty row for now. So to enable row reuse later, we extract the root target type of a widget and create an empty row with it.\neg.\nfun item -\u0026gt; ViewCell( Grid(...) )  will have a target type of ViewCell and we create an empty ViewCell.\nSide note: Given the potential high cost of instantiate a lot of View.lazy', its use is not allowed in virtualized collections.\nThis DataTemplateSelector instantiates a WidgetDataTemplate that will create the appropriate XF control and listen to BindingContextChanged.\n/// Create a DataTemplate for a specific root type (TextCell, ViewCell, etc.) /// that listen for BindingContext change to apply the Widget content to the cell type WidgetDataTemplate(``type``, itemType, parent: IViewNode) = inherit DataTemplate(fun () -\u0026gt; let bindableObject = Activator.CreateInstance ``type`` :?\u0026gt; BindableObject let viewNode = ViewNode(ValueSome parent, parent.TreeContext, WeakReference(bindableObject)) bindableObject.SetValue(ViewNode.ViewNodeProperty, viewNode) let onBindingContextChanged = BindableHelpers.createOnBindingContextChanged parent.TreeContext.CanReuseView itemType bindableObject bindableObject.BindingContextChanged.Add (fun _ -\u0026gt; onBindingContextChanged ()) bindableObject :\u0026gt; obj )  For fresh rows, Xamarin.Forms will execute that function and then set the BindingContext with the widget from our list. When XF reuses a row, it will set the new widget in the BindingContext as well. Each time, we call the Reconciler to update the row.\nFinal step is to pass this WidgetDataTemplateSelector in the XF property ItemTemplate. Since it will never change, we assign it when creating the controls.\n/// Force ListView to recycle rows because DataTemplateSelector disables it by default, only possible in ctor /// CollectionView recycles by default type FabulousListView() = inherit ListView(ListViewCachingStrategy.RecycleElement) let ListView = Widgets.registerWithAdditionalSetup\u0026lt;FabulousListView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) ) let CollectionView = Widgets.registerWithAdditionalSetup\u0026lt;Xamarin.Forms.CollectionView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) )  A registerWithAdditionalSetup was needed because DataTemplateSelector requires access to the ViewNode of the ListView/CollectionView, and it was not possible to do it in the constructor of the controls.\nGrouped collections # Grouped ListView/CollectionView is slightly different. Instead of having a 1-dimensional enumerable of raw data, we have a 2-dimension one (eg. IEnumerable\u0026lt;IEnumerable\u0026lt;T\u0026gt;\u0026gt;)\nTo support this with everything we saw just before, GroupItem has been created.\ntype GroupItem(header: Widget, footer: Widget, source: IEnumerable\u0026lt;Widget\u0026gt;) = member _.Header = header member _.Footer = footer interface IEnumerable\u0026lt;Widget\u0026gt; with member this.GetEnumerator(): IEnumerator\u0026lt;Widget\u0026gt; = source.GetEnumerator() member this.GetEnumerator(): IEnumerator = source.GetEnumerator()  Instead of applying a list of IEnumerable\u0026lt;Widget\u0026gt; to XF property ItemsSource, we apply a list of IEnumerable\u0026lt;GroupItem\u0026gt;.\nThe builder function takes 3 template functions instead of 1: the group header template, the item template and the group footer template. All of which are called on ConvertValue to create the list of \u0026lsquo;GroupItem\u0026rsquo;.\nSince the data source is different, we need a different DataTemplate for XF properties GroupHeaderTemplate and GroupFooterTemplate. Even with grouping enabled, ItemTemplate remains a simple Widget -\u0026gt; row.\nGroupedWidgetDataTemplateSelector will either use the Header or Footer widgets to create the corresponding rows.\nAnd when registering the ListView/CollectionView types, we enable the IsGrouped flag.\nlet GroupedListView = Widgets.registerWithAdditionalSetup\u0026lt;FabulousListView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) target.GroupHeaderTemplate \u0026lt;- GroupedWidgetDataTemplateSelector(node, Header) target.IsGroupingEnabled \u0026lt;- true ) let GroupedCollectionView = Widgets.registerWithAdditionalSetup\u0026lt;Xamarin.Forms.CollectionView\u0026gt;(fun target node -\u0026gt; target.ItemTemplate \u0026lt;- SimpleWidgetDataTemplateSelector(node) target.GroupHeaderTemplate \u0026lt;- GroupedWidgetDataTemplateSelector(node, Header) target.GroupFooterTemplate \u0026lt;- GroupedWidgetDataTemplateSelector(node, Footer) target.IsGrouped \u0026lt;- true )  "}).add({id:3,href:"/docs/architecture/",title:"Architecture",description:"Architecture",content:""}).add({id:4,href:"/docs/",title:"Docs",description:"Docs",content:""}).add({id:5,href:"/docs/introduction/",title:"Docs",description:"Docs",content:"Introduction to Fabulous v2\n"}).add({id:6,href:"/docs/quickstarts/",title:"Quickstarts",description:"Quickstarts",content:""}).add({id:7,href:"/docs/tutorials/",title:"Tutorials",description:"Tutorials",content:""}),search.addEventListener('input',b,!0);function b(){var b,e;const d=5;b=this.value,e=a.search(b,{limit:d,enrich:!0});const c=new Map;for(const a of e.flatMap(a=>a.result)){if(c.has(a.doc.href))continue;c.set(a.doc.href,a.doc)}if(suggestions.innerHTML="",suggestions.classList.remove('d-none'),c.size===0&&b){const a=document.createElement('div');a.innerHTML=`No results for "<strong>${b}</strong>"`,a.classList.add("suggestion__no-results"),suggestions.appendChild(a);return}for(const[h,g]of c){const b=document.createElement('div');suggestions.appendChild(b);const a=document.createElement('a');a.href=h,b.appendChild(a);const e=document.createElement('span');e.textContent=g.title,e.classList.add("suggestion__title"),a.appendChild(e);const f=document.createElement('span');if(f.textContent=g.description,f.classList.add("suggestion__description"),a.appendChild(f),suggestions.appendChild(b),suggestions.childElementCount==d)break}}})()