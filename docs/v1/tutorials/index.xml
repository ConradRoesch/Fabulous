<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tutorials on</title><link>https://docs.fabulous.dev/docs/v1/tutorials/</link><description>Recent content in Tutorials on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Thu, 31 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://docs.fabulous.dev/docs/v1/tutorials/index.xml" rel="self" type="application/rss+xml"/><item><title>How to write your own extensions</title><link>https://docs.fabulous.dev/docs/v1/tutorials/how-to/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://docs.fabulous.dev/docs/v1/tutorials/how-to/</guid><description>Many open source and 3rd-party libraries of Xamarin.Forms controls exist. To use other controls, a small amount of wrapper code is typically needed to define a corresponding view element using the incremental-update model used by Fabulous.
The following additional view elements are available as pre-built nuget libraries:
FFImageLoading for cached images, as opposed to the built-in Image view that wastes time and memory Maps for platform maps SkiaSharp for drawing 2D graphics OxyPlot for charting VideoManager for playing audio and video To use other Xamarin.</description></item><item><title>Models</title><link>https://docs.fabulous.dev/docs/v1/tutorials/model/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://docs.fabulous.dev/docs/v1/tutorials/model/</guid><description>The model is the core data from which the whole state of the app can be resurrected. The model is generally immutable but may also contain elements such as service connections. It is common for the desgin of the model to grow &amp;ldquo;organically&amp;rdquo; as you prototype your app.
The init function returns your initial model. The update function updates the model as messages are received.
Messages and Validation # Validation is generally done on updates to the model storing error messages from validation logic in the model so they can be correctly and simply displayed to the user.</description></item><item><title>MVU</title><link>https://docs.fabulous.dev/docs/v1/tutorials/mvu/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://docs.fabulous.dev/docs/v1/tutorials/mvu/</guid><description>Applications built with Fabulous use the MVU design pattern (Model-View-Update, also known from the origin The Elm Architecture).
Here is the typical structure for the main logic of an app:
type Msg = | ... /// The MODEL from which the view is generated type Model = { ... } /// Returns the initial state let init() = { ... } /// The funtion to UPDATE the view let update (msg:Msg) (model:Model) = .</description></item><item><title>Pitfalls and F# 5.0 support</title><link>https://docs.fabulous.dev/docs/v1/tutorials/dev-pitfalls/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://docs.fabulous.dev/docs/v1/tutorials/dev-pitfalls/</guid><description>Here are some common pitfalls you might encounter when using Fabulous.
Can Fabulous target .NET 5 / use .NET 5 libraries? # Microsoft announced .NET 5 along with F# 5.0 during .NET Conf 2020.
Before .NET 5 came, there were 3 differents .NET frameworks: .NET Framework, .NET Core and Mono.
Historically, all Xamarin projects (Android, iOS, macOS and many other) run on Mono.
Since Fabulous.XamarinForms is built on top of Xamarin.</description></item><item><title>Testing</title><link>https://docs.fabulous.dev/docs/v1/tutorials/dev-testing/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://docs.fabulous.dev/docs/v1/tutorials/dev-testing/</guid><description>The Model-View-Update architecture used by Fabulous makes it simple to unit test every part of your application.
Apps are composed of 3 key pure F# functions: init, update and view
They take some parameters and return a value. Ideal for unit testing.
Testing init # init is the easiest one to test.
It usually takes nothing and returns a value.
Let&amp;rsquo;s take this code for example:
type Model = { Count: int Step: int } let init () = { Count = 0; Step = 1 } Here we can make sure that the default state stays exact throughout the life of the project.</description></item><item><title>The Init and Update Functions</title><link>https://docs.fabulous.dev/docs/v1/tutorials/update/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://docs.fabulous.dev/docs/v1/tutorials/update/</guid><description>The init function returns an initial model, and the update function processes a message and returns a new model:
type Model = { TimerOn: bool } type Message = | TimerToggled of bool let init () = { TimerOn = false } let update msg model = match msg with | TimerToggled on -&amp;gt; { model with TimerOn = on } Commands # A command (type Cmd) is a callback that can dispatch messages, i.</description></item><item><title>Traces and crashes</title><link>https://docs.fabulous.dev/docs/v1/tutorials/dev-logging/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://docs.fabulous.dev/docs/v1/tutorials/dev-logging/</guid><description>In Fabulous, everything happens in a centralized message loop that is responsible for calling your init, update and view functions.
Fabulous allows you to plug into this loop to run custom logic such as logging and error handling.
There&amp;rsquo;s a few built-in functions available already:
Functions Description Program.withConsoleTrace Print every message, model and exception received and/or generated by the init, update and view functions.</description></item><item><title>Using the Fabulous command line</title><link>https://docs.fabulous.dev/docs/v1/tutorials/dev-tools/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://docs.fabulous.dev/docs/v1/tutorials/dev-tools/</guid><description>With the fabulous-cli you can run LiveUpdate.
Install fabulous-cli:
// install latest dotnet tool install -g fabulous-cli // install explicit version dotnet tool install -g fabulous-cli --version {versionnumber} Update fabulous-cli:
dotnet tool update -g fabulous-cli Uninstall fabulous-cli:
dotnet tool uninstall -g fabulous-cli Live Update # There is an experimental LiveUpdate mechanism available. The aim of this is primarily to enable modifying the view function in order to see the effect of adjusting of visual options.</description></item><item><title>Views</title><link>https://docs.fabulous.dev/docs/v1/tutorials/view/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://docs.fabulous.dev/docs/v1/tutorials/view/</guid><description>The view function is a function returning your view elements based on the current model. For example:
let view model dispatch = View.ContentPage( title=&amp;quot;Pocket Piggy Bank&amp;quot;, content=View.Label(text = sprintf &amp;quot;Hello world!&amp;quot;) ) The view function is normal F# code that returns elements created using the View.* method calls.
View functions are particularly useful when the existence, characteristics and layout of the view depends on information in the model. Differential update is used to efficiently update the Xamarin.</description></item></channel></rss>